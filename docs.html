<!DOCTYPE html>
<html lang="en">

<head>
	<title>GolangDocker</title>
	<!-- Meta -->
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Using Golang, Docker, and Kubernetes">
	<meta name="author" content="Matt J. Wiater">
	<meta property='og:title' content='Creating a compiled Golang binary for use in a minimal Docker container'/>
	<meta property='og:image' content='https://raw.githubusercontent.com/mwiater/golangdocker/main/_repository_assets/golangdocker-og-image.png'/>
	<meta property='og:description' content='Using compiled Golang apps, Docker, and Kubernetes together for portability, consistency, and scalability'/>
	<meta property='og:url' content='https://mwiater.github.io/golangdocker/'/>
	<meta property="og:type" content="website" />
	<link rel="shortcut icon" href="favicon.ico">
	<!-- Google Tag Manager -->
	<script>(function (w, d, s, l, i) {
			w[l] = w[l] || []; w[l].push({
				'gtm.start':
					new Date().getTime(), event: 'gtm.js'
			}); var f = d.getElementsByTagName(s)[0],
				j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
					'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
		})(window, document, 'script', 'dataLayer', 'GTM-NZCKWQM');</script>
	<!-- End Google Tag Manager -->
	<!-- Google Font -->
	<link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">
	<!-- FontAwesome JS-->
	<script src="https://kit.fontawesome.com/5ae6879468.js" crossorigin="anonymous"></script>
	<!-- Plugins CSS -->
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/atom-one-dark.min.css">
	<link rel="stylesheet" href="assets/plugins/simplelightbox/simple-lightbox.min.css">
	<!-- Theme CSS -->
	<link id="theme-style" rel="stylesheet" href="assets/css/theme.css">
	<link id="theme-style" rel="stylesheet" href="assets/css/app.css">
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
	<meta name="theme-color" content="#ffffff">
</head>

<body class="docs-page">
	<!-- Google Tag Manager (noscript) -->
	<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NZCKWQM" height="0" width="0"
			style="display:none;visibility:hidden"></iframe></noscript>
	<!-- End Google Tag Manager (noscript) -->
	<header class="header fixed-top">
		<div class="branding docs-branding">
			<div class="container-fluid position-relative py-2">
				<div class="docs-logo-wrapper">
					<button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible me-2 d-xl-none"
						type="button">
						<span></span>
						<span></span>
						<span></span>
					</button>
					<div class="site-logo">
						<a class="navbar-brand" href="index.html">
							<i class="fa-duotone fa-box-check fa-fw"></i>
							<span class="logo-text"> Golang
								<span class="text-alt">Docker</span>
							</span>
						</a>
					</div>
				</div>
				<!--//docs-logo-wrapper-->
				<div style="float:right;font-size: 2em;margin-right: 20px;margin-top: 4px;"><a style="color: #000000;"
						target="_blank" href="https://github.com/mwiater/golangdocker"><i class="fa-brands fa-github"></i></a></div>
			</div>
			<!--//container-->
		</div>
		<!--//branding-->
	</header>
	<!--//header-->
	<div class="docs-wrapper">
		<div id="docs-sidebar" class="docs-sidebar">
			<nav id="docs-nav" class="docs-nav navbar">
				<ul class="section-items list-unstyled nav flex-column pb-3">
					<li class="nav-item section-title"><a class="nav-link scrollto" href="#project-motivation"><span
								class="theme-icon-holder me-2"><i class="fa-duotone fa-chalkboard-user fa-fw"></i></span>Project
							Motivation</a>
					</li>
					<li class="nav-item section-title"><a class="nav-link scrollto" href="#golang-application"><span
								class="theme-icon-holder me-2"><img style="margin-top: -4px;margin-left: -1px;"
									src="assets/images/golang-logo-green.svg" alt="logo"></span>Golang Application</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#golang-application-topics">Project Topics</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#golang-application-assumptions">Assumptions</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#golang-application-prerequisites">Prerequisites</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#golang-application-installation">Installation</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#golang-application-makefile">Makefile</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#golang-application-run">Running the Application</a>
					</li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#docker"><span
								class="theme-icon-holder me-2"><i class="fa-brands fa-docker fa-fw"></i></span>Docker</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#docker-building-the-docker-container">Building the
							Docker container</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#docker-docker-build-notes">Docker Build Notes</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#docker-running-the-docker-container">Running the
							Docker container</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#docker-container-resource-constraints">Docker container resource constraints</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto"
							href="#docker-breakdown-running-multiple-docker-containers">Breakdown: Running Multiple Docker
							Containers</a>
					</li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#tests"><span
								class="theme-icon-holder me-2"><i class="fa-duotone fa-flask-vial fa-fw"></i></span>Tests</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#tests-run">Run</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#tests-clear-test-cache">Clear Test Cache</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#linting"><span
								class="theme-icon-holder me-2"><i
									class="fa-duotone fa-screwdriver-wrench fa-fw"></i></span></span>Linting</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#linting-golangci-lint">golangci-lint</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#godoc"><span
								class="theme-icon-holder me-2"><i class="fa-duotone fa-file-invoice fa-fw"></i></span>GoDoc</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#godoc-usage">Usage</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#load-testing"><span
								class="theme-icon-holder me-2"><i class="fa-duotone fa-weight-hanging fa-fw"></i></span>Load Testing</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-installation">Installation</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-plugins">Plugins</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-test-phases">Test Phases</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-custom-scripts">Custom Scripts</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-load-tests">Load Tests</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-no-container-bare-app">No container,
							bare app</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-docker-container">Docker container</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-kubernetes">Kubernetes</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#kubernetes"><span
								class="theme-icon-holder me-2"><i class="fa-duotone fa-chart-network fa-fw"></i></span>Kubernetes</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-assumptions">Assumptions</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-load-balancer">Load Balancer</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-metal-lb">Metal LB</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-create-namespace">Create Namespace</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-create-deployment">Create Deployment</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-create-service">Create Service</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-create-ingress">Create Ingress</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-horizontal-pod-autoscaler">Horizontal Pod
							Autoscaler (HPA)</a>
					</li>
				</ul>
			</nav>
			<!--//docs-nav-->
		</div>
		<!--//docs-sidebar-->
		<div class="docs-content">
			<div class="container">
				<article class="docs-article" id="project-motivation">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-chalkboard-user fa-fw" style="color: #28b76b;"></i> Project
							Motivation
						</h1>
						<section class="docs-intro">
							<p>
							<h3>Why Golang?</h3>
							</p>
							<p>In my career at agencies and startups, rapid prototyping is essential. Ruby tended to by the language
								of choice for many of these projects, as it's easy to get something built quickly, and if you follow
								style guidelines, easy to read. But as these sites and apps began to scale, runtime speed, the need for
								concurrency, memory management, and throughput became common bottlenecks with Ruby. Note: I'm not language-bashing here&mdash;I still use Ruby on a daily basis&mdash;<i>but there's never a single language that's right for all projects.</i>
							</p>
							<p>Go is a statically typed and compiled language. While not as easy as Ruby was to jump in and create
								working proof-of-concepts from the start, the fundamentals of the language made sense. Once you get the
								Go concepts and syntax down (it is not an object oriented language),
								it's easy to move forward quickly. And for a relatively young language, it has a high adoption rate and
								vast community support and feature-complete packages.
							</p>
							<p>Also, since Golang apps can be compiled into a single binary and executed with minimal OS
								resources/toolchains (See the <a href="#docker-docker-build-notes">Docker Build Notes</a> static build
								section below), we can create a container with a very small footprint. As shown in the tutorial,
								Go can already compile for many different target platforms as well, which makes it easy to build
								binaries for, say, both x86 and Arm architectures. </p>
							<p>
							<h3>Why Docker?</h3>
							</p>
							<p>Breaking down application components into separate, unique services allows the engineer to work within
								confined, single-purpose environments. This is in opposition to singular monoliths, where chipping away
								in one section of the code can have negative cascading consequences within the rest of the application
								due to internal dependencies. I often follow the <b><a target="_blank"
										href="https://12factor.net/">12 Factor App</a></b> methodology, which does a great job of explaining
								the details, architecture, and reasoning behind the process. For a companion piece about how this project specifically relates to the 12-factor-app, see my article on DevGenius: <b><a target="_blank"
								href="https://blog.devgenius.io/creating-a-compiled-golang-binary-for-use-in-a-minimal-docker-container-ae1c5a720aab">Creating a compiled Golang binary for use in a minimal Docker container as defined by the 12 Factor App methodology</a></b>. 
							</p>
							<p>Using Docker properly can ease you into creating 12 Factor applications by forcing the engineer to
								think about not only breaking down an app into microservices, but also the potential application
								architecture involved. Also, by creating single purpose containers, you'll often be guided towards more
								parity with the production landscape, e.g.: different services in the AWS and Google Cloud Platform
								stacks.
							</p>
							<p>Rather than developing an app on a Linux system and using the OS as a shared resource (e.g.: running
								web and database services), splitting these into separate containers services will accomplish several
								things. Firstly, it will declare and isolate the service dependencies. Web service dependencies are
								different than Database server dependencies. When you develop on a single machine, the dependencies for
								all pieces of the application are installed with access by the underlying shared OS. When running them
								in Docker containers, these dependencies are specific to the app service inside the container.
							</p>
							<p>
							<h3>Why Kubernetes?</h3>
							</p>
							<p>As mentioned in the above Docker section, microservice architecture can be essential in building
								highly-scalable applications. The Kubernetes section will give a high-level view of the components
								involved in a K8s cluster so that the Docker container can be replicated across nodes and accessed via
								a single endpoint.
							</p>
							<p>
							<h3>What it is</h3>
							</p>
							<p>This project is meant to be a high-level view of tying some basic <a
									href="#golang-application">Golang</a> and <a href="#docker">Docker</a> concepts together. It is meant
								to be a starting point, by highlighting both Go and Docker fundamentals, basic commands and tools, and
								an understanding of how Go and Docker can work together to build fast, lightweight, and portable
								containers.</p>
							<p>
							<h3>What it ain't</h3>
							</p>
							<p>While I've provided some basic working ideas and a buildable, working application, you should already
								have some fundamental knowledge of Go and Docker.</p>
						</section>
						<!--//docs-intro-->
					</header>
				</article>
				<article class="docs-article" id="golang-application">
					<header class="docs-header">
						<h1 class="docs-heading"><img style="height: 100px;margin-top: -8px;margin-left: -15px;margin-right: -10px;"
								src="assets/images/golang-logo-green.svg" alt="logo"> Golang Application
						</h1>
						<section class="docs-intro">
							<p>This repository is a work in progress, but I'll do my best to keep the Main branch in a working
								state. Initially, this project was to create a boilerplate for containerizing Go binaries for use in a
								K8s cluster. For now, just organizing my notes in order to be able to replicate this process from
								end-to-end. The idea is to keep this narrow and succinct and be able to use this as a simple boilerplate
								for Go containers.
							</p>
						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="golang-application-topics">
						<h2 class="section-heading">Project Topics</h2>
						<p>This project is in three distinct parts, each which build on the previous:</p>
						<h5 id="1-a-simple-but-functioanl-rest-api-app-written-in-go-this-rest-api-incorporates-">1) A simple but
							functioanl <a href="#golang-application-run">rest API app written in Go</a>. This rest API incorporates:
						</h5>
						<ul>
							<li>The <a href="https://docs.gofiber.io/api/middleware/monitor">Fiber Monitor middleware</a> (API
								endpoint:
								<code>/api/v1/metrics</code>).
							</li>
							<li>Creating and serving API documentation (using <code>swag init</code>) based on <a
									href="https://swagger.io/docs/specification/about/">Swagger specifications</a>:
								<code>/api/v1/docs/</code>).
							</li>
							<li>A <code>YAML</code> configuration pattern for setting app variables.</li>
							<li>Basic Go endpoint tests via <code>go test</code>.</li>
							<li>Building a binary of the app and embedding external files (both native compilation and
								cross-compilation
								for <code>armv6</code> as an example) so that it is portable and self contained.
							</li>
							<li>
								Go Tools
								<ul>
									<li>File formatting for *.go files using <code>gofmt</code>.</li>
									<li>Code linting for *.go files using <code>golangci-lint</code>.</li>
									<li>Code documentation via <code>godoc</code>.</li>
								</ul>
							</li>
						</ul>
						<h5 id="2-using-the-app-in-a-docker-container-covering-">2) Using the <a href="#docker">app in a Docker
								container</a>, covering:
						</h5>
						<ul>
							<li><a href="https://docs.docker.com/engine/reference/commandline/build/">Docker build</a> concepts.</li>
							<li><a href="https://docs.docker.com/engine/reference/commandline/run/">Docker run</a> concepts.</li>
							<li>Docker image versioning.</li>
							<li>Ways to make use of bash scripts for repetitive tasks.</li>
						</ul>
						<h5 id="3-using-the-docker-container-in-kubernetes">3) Using the <a href="#kubernetes">Docker container in
								Kubernetes</a></h5>
						<ul>
							<li>This section is the most incomplete, but should be in a working state.</li>
							<li>You should already have a working K8s cluster available for this section.</li>
							<li>Does not provide much background, assumes some basic knowledge using <code>kubectl</code>.</li>
							<li>This app will be deployed as a load-balanced Service across a Control Plane and 3 Worker nodes.</li>
						</ul>
					</section>
					<!--//section-->
					<section class="docs-section" id="golang-application-assumptions">
						<h2 class="section-heading">Assumptions</h2>
						<ul>
							<li><strong>IP Addresses:</strong> For the most part, disregard the hard-coded IP addresses in here (e.g.:
								my K8s cluster and VM IPs (192.168.<em>.</em>)). You&#39;ll have to sub in your own for your particular
								environment. Right now, laziness!
							</li>
							<li><strong>Container vs. Pod:</strong> I&#39;m noticing a few instances where I&#39;m using both
								<code>container</code> and <code>pod</code> to mean the same thing in the K8s section. Until I make them
								more consistent, assume they are interchangeable. A pod is basically a container in in K8s context.
								While
								a <code>pod</code> can technically have multiple containers, for this demonstration, assume a 1:1
								relationship.
							</li>
							<li><strong>System</strong> My system and architecture is below, you&#39;ll have to adjust your commands
								if
								you&#39;re departing from Linux/x86_64.
							</li>
						</ul>
						<p><code>uname -a</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<pre><code>Linux mjw-udoo-01 5.4.0-110-generic 124-Ubuntu SMP Thu Apr 14 19:46:19 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</code></pre>
					</section>
					<!--//section-->

					<section class="docs-section" id="golang-application-prerequisites">
						<h2 class="section-heading">Prerequisites</h2>
						<h4><code>.env</code> file:</h4>
						<p>The <code>.env</code> file contains the configuration for your app, and is used in the Docker build and
							run
							processes.
						</p>
						<p>
						<pre><code>SERVERPORT=5000
DOCKERPORT=5000
DEBUG=false
DOCKERIMAGE=mattwiater/golangdocker</code></pre>
						</p>
						<ul>
							<li><b>SERVERPORT:</b> The port to open for the Golang app. Value: 5000</li>
							<li><b>DOCKERPORT:</b> The port to open for Docker to map to the port above.Value: 5000</li>
							<li><b>DEBUG:</b> Turn on debugging. Value: true/false</li>
							<li><b>DOCKERIMAGE:</b> The tag for your Docker image. Value:
								<code>{your-docker-hub-account-username}/{your-docker-hub-image-name}</code>

								<div class="callout-block callout-block-info">
									<div class="content">
										<h4 class="callout-title">
											<span class="callout-icon-holder me-1">
												<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false"
													data-prefix="fas" data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg"
													viewBox="0 0 512 512" data-fa-i2svg="">
													<path fill="currentColor"
														d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
													</path>
												</svg>
												<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
											</span>
											<!--//icon-holder-->
											Note
										</h4>
										<p>The steps will refer to the docker image: <code>mattwiater/golangdocker</code>. You should change
											these steps to match your own image name in the <code>.env</code> file, e.g.:
											<code>DOCKERIMAGE={your-docker-hub-account-username}/golangdocker</code>
										</p>
									</div>
									<!--//content-->
								</div>

								<div class="callout-block callout-block-warning">
									<div class="content">
										<h4 class="callout-title">
											<span class="callout-icon-holder me-1">
												<svg class="svg-inline--fa fa-bullhorn" aria-hidden="true" focusable="false" data-prefix="fas"
													data-icon="bullhorn" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
													data-fa-i2svg="">
													<path fill="currentColor"
														d="M480 179.6C498.6 188.4 512 212.1 512 240C512 267.9 498.6 291.6 480 300.4V448C480 460.9 472.2 472.6 460.2 477.6C448.3 482.5 434.5 479.8 425.4 470.6L381.7 426.1C333.7 378.1 268.6 352 200.7 352H192V480C192 497.7 177.7 512 160 512H96C78.33 512 64 497.7 64 480V352C28.65 352 0 323.3 0 288V192C0 156.7 28.65 128 64 128H200.7C268.6 128 333.7 101 381.7 53.02L425.4 9.373C434.5 .2215 448.3-2.516 460.2 2.437C472.2 7.39 480 19.06 480 32V179.6zM200.7 192H192V288H200.7C280.5 288 357.2 317.8 416 371.3V108.7C357.2 162.2 280.5 192 200.7 192V192z">
													</path>
												</svg><!-- <i class="fas fa-bullhorn"></i> Font Awesome fontawesome.com -->
											</span><!--//icon-holder-->
											Important
										</h4>
										<p>If you want to tag the image differently, adjust the <code>DOCKERIMAGE</code> env variable to
											include an explicit tag in the format:
											<code>{your-docker-hub-account-username}/{your-docker-hub-image-name}</code> For example, if it is
											aVersion 1release, you might tag it <code>:v1</code>, e.g.:
											<code>mattwiater/golangdocker:v1</code>
										</p>
									</div>
									<!--//content-->
								</div>


							</li>
						</ul>
						<p><b>Required for Kubernetes integration:</b></p>
						<ul>
							<li>A running <a href="https://kubernetes.io/">Kubernetes</a> cluster</li>
							<li>A <a href="https://hub.docker.com/">Docker Hub</a> account</li>
						</ul>
						<p><b>Optional:</b></p>
						<ul>
							<li>Artillery (nodejs): <a href="loadTesting.html">Load
									Testing</a>
							</li>
						</ul>
						<p>While the idea is to get this up and running quickly, it is not a deep dive into Go, Docker, or K8S.
							Basic
							knowledge of these technologies is required.
						</p>
						<p>For example, we can peek into the container via the API endpoint <code>api/v1/host</code> and see the
							docker assigned <code>hostname: &quot;b189564db0c5&quot;</code> and verify that it is one running a single
							process <code>procs: 1</code>:
						</p>
						<pre><code>{
  hostInfo: {
    hostname: "b189564db0c5",
    uptime: 1238849,
    bootTime: 1667920883,
    procs: 1,
    os: "linux",
    platform: "",
    platformFamily: "",
    platformVersion: "",
    kernelVersion: "5.4.0-110-generic",
    kernelArch: "x86_64",
    virtualizationSystem: "docker",
    virtualizationRole: "guest",
    hostId: "12345678-1234-5678-90ab-cddeefaabbcc"
    }
  }</code></pre>
					</section>
					<!--//section-->

					<section class="docs-section" id="golang-application-installation">
						<h2 class="section-heading">Installation</h2>
						<p>The following programs will need to be installed:</p>
						<ul>
							<li><a href="https://go.dev/learn/">Go</a></li>
							<li><a href="https://www.docker.com/get-started/">Docker</a></li>
						</ul>

						<h4>My development environment</h4>

						<p><code>more /etc/os-release</code>: Ubuntu 20.04.5 LTS</p>
						<p><code>go version</code>: go1.18.5 linux/amd64</p>
						<p><code>docker -v</code>: Docker version 20.10.12, build 20.10.12-0ubuntu2~20.04.1</p>

						<h4>Simple Setup:</h4>

						<p>
						<pre><code>git clone git@github.com:mwiater/golangdocker.git
cd golangdocker
go get
go install github.com/swaggo/swag/cmd/swag@latest</code></pre>
						</p>

						<h4>Preferred Setup: Anaconda</h4>
						<p>
						<ul>
							<li>Follow setup for your system here: <a target="_blank"
									href="https://docs.anaconda.com/anaconda/install/">https://docs.anaconda.com/anaconda/install/</a>
							</li>
							<li>Anaconda distributions: <a target="_blank"
									href="https://www.anaconda.com/products/distribution">https://www.anaconda.com/products/distribution</a>
							</li>
						</ul>
						</p>
						<p>Once installed, you'll also need a compiler for your system, e.g. for Ubuntu:
							<code>conda install gxx_linux-64</code>
						</p>

						<p>Create the environment: <code>conda create -c conda-forge -n golangdocker go</code></p>

						<p>Verify: <code>conda info --envs</code></p>

						<p>
						<pre><code># conda environments:
#
base                     /home/matt/anaconda3
golangdocker             /home/matt/anaconda3/envs/golangdocker</code></pre>
						</p>

						<p>Activate: <code>conda activate golangdocker</code></p>

						<p>
						<pre><code>git clone git@github.com:mwiater/golangdocker.git
						cd golangdocker
						go get
						go install github.com/swaggo/swag/cmd/swag@latest</code></pre>
						</p>

						<p></p>
						When you're finished with the environment, you can deactivate it: <code>conda deactivate</code></p>

						<p>
							Or, remove it completely: <code>conda env remove -n golangdocker</code></p>

					</section>

					<section class="docs-section" id="golang-application-makefile">
						<h2 class="section-heading">Makefile</h2>
						<p>There is a <a target="_blank"
								href="https://github.com/mwiater/golangdocker/blob/main/Makefile">Makefile</a>
							for convenience. At the moment, it&#39;s just acting as a script-runner.
							To view the executable targets, just type: <code>make</code>
						</p>
						<pre><code>Targets in this Makefile:

make docker-build
make docker-run
make golang-build
make golang-build-arm64
make golang-godoc
make golang-lint
make golang-run
make golang-test

For details on these commands, see the bash scripts in the 'scripts/' directory.</code></pre>
						<p>The bash scripts executed by the Makefile live in the <a target="_blank"
								href="https://github.com/mwiater/golangdocker/tree/main/scripts">/scripts</a> directory.</p>

						<div class="callout-block callout-block-info">
							<div class="content">
								<h4 class="callout-title">
									<span class="callout-icon-holder me-1">
										<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
											data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
											data-fa-i2svg="">
											<path fill="currentColor"
												d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
											</path>
										</svg>
										<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
									</span>
									<!--//icon-holder-->
									Note
								</h4>
								<p>Many of the bash scripts execute helpers before the main command, e.g.: <code>swag init</code>,
									<code>gofmt</code>, etc. There are exit status checks in place so that, for example, if
									<code>gofmt</code> fails prior to the build (usually because of a syntax error), the script will
									report the error and exit before trying to build the go binary--which would likely fail due to the
									error found via <code>gofmt</code>. Here is an example of the script pattern:

								<pre><code>...
echo -e "${CYANBOLD}Building Swagger docs...${RESET}"
swag init
status=$?
if test $status -ne 0
then
	echo -e "${REDBOLD}...Error: 'swag init' command failed:${RESET}"
	echo ""
	exit 1
fi
echo -e "${GREENBOLD}...Complete.${RESET}"
echo ""

echo -e "${CYANBOLD}Formatting *.go files...${RESET}"
for i in *.go **/*.go ; do
	gofmt -w "$i"
	status=$?
	if test $status -ne 0
	then
		echo -e "${REDBOLD}...Error: 'gofmt' command failed!${RESET}"
		echo ""
		exit 1
	fi
	echo "Formatted: $i"
done;
echo -e "${GREENBOLD}...Complete${RESET}"
echo ""
...</code></pre>
								</p>
							</div>
							<!--//content-->
						</div>

					</section>
					<!--//section-->
					<section class="docs-section" id="golang-application-run">
						<h2 class="section-heading">Running the Application</h2>
						<p>while developing the app, you should run it natively (not in a Docker container) via:</p>
						<p><code>go run main.go</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i></p>
						<p>Or, for convenience, run: <code>make golang-run</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
						<p>Site will be available at: <a href="http://192.168.0.91:5000/api/v1">http://192.168.0.91:5000/api/v1</a>
							(substitute your own IP address)
						</p>

						<div class="callout-block callout-block-warning">
							<div class="content">
								<h4 class="callout-title">
									<span class="callout-icon-holder me-1">
										<svg class="svg-inline--fa fa-bullhorn" aria-hidden="true" focusable="false" data-prefix="fas"
											data-icon="bullhorn" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
											data-fa-i2svg="">
											<path fill="currentColor"
												d="M480 179.6C498.6 188.4 512 212.1 512 240C512 267.9 498.6 291.6 480 300.4V448C480 460.9 472.2 472.6 460.2 477.6C448.3 482.5 434.5 479.8 425.4 470.6L381.7 426.1C333.7 378.1 268.6 352 200.7 352H192V480C192 497.7 177.7 512 160 512H96C78.33 512 64 497.7 64 480V352C28.65 352 0 323.3 0 288V192C0 156.7 28.65 128 64 128H200.7C268.6 128 333.7 101 381.7 53.02L425.4 9.373C434.5 .2215 448.3-2.516 460.2 2.437C472.2 7.39 480 19.06 480 32V179.6zM200.7 192H192V288H200.7C280.5 288 357.2 317.8 416 371.3V108.7C357.2 162.2 280.5 192 200.7 192V192z">
											</path>
										</svg><!-- <i class="fas fa-bullhorn"></i> Font Awesome fontawesome.com -->
									</span><!--//icon-holder-->
									Warning
								</h4>
								<p>This step should be completed first before running via Docker to ensure everything is working
									properly with the application itself. If errors are introduced at this point, they will simply be
									carried over when trying to run it in a Docker container.</p>
							</div><!--//content-->
						</div>

						<h4>Application Output</h4>

						<p>When running the app, you should see output similar to:</p>

						<pre><code>┌────────────────────────────────────────────────────┐
│                   Fiber v2.40.0                    │
│               http://127.0.0.1:5000                │ 
│       (bound on host 0.0.0.0 and port 5000)        │
│                                                    │
│ Handlers ............ 14  Processes ........... 1  │
│ Prefork ....... Disabled  PID ................. 1  │
└────────────────────────────────────────────────────┘</code></pre>

						<p>To get an understanding of each of the endpoints, explore them while the app is running:</p>

						<pre><code>/
/api/v1
/api/v1/docs/
/api/v1/metrics
/api/v1/resource/
/api/v1/resource/all
/api/v1/resource/cpu
/api/v1/resource/host
/api/v1/resource/load
/api/v1/resource/memory
/api/v1/resource/network</code></pre>


						<h4>Swagger Docs</h4>

						<p>As an API documentation example, this app is bundled with Swagger UI Documentation, available at the
							<code>/api/v1/docs/</code> API endpoint. Along with documented endpoints, there is a full REST interface
							to
							test out API calls through the browser, complete with curl examples and header information.
						</p>

						<div class="simplelightbox-gallery row mb-1">
							<div class="col-12 col-md-4 mb-3">
								<a href="assets/images/swagger-ui.png"><img class="figure-img img-fluid shadow rounded"
										src="assets/images/swagger-ui-thumbnail.png" alt="" title="Swagger UI" /></a>
							</div>
						</div><!--//gallery-->
					</section>
					<!--//section-->
				</article>
				<article class="docs-article" id="docker">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-brands fa-docker fa-fw" style="color: #28b76b;"></i>
							Docker
						</h1>
						<section class="docs-intro">
							<p>In this section, we will take our working application binary and wrap it in a bare-minimum Docker
								container.
							</p>
							<p>For installation on your system, see the <a href="https://docs.docker.com/get-docker/">official
									documentation</a>.
							</p>
						</section>
						<section class="docs-section" id="docker-building-the-docker-container">
							<h2 id="building-the-docker-container">Building the Docker container</h2>

							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note
									</h4>
									<p>The steps will refer to the docker image: <code>mattwiater/golangdocker</code>. You should change
										these steps to match your own image name in the <code>.env</code> file, e.g.:
										<code>DOCKERIMAGE={your-docker-hub-account-username}/golangdocker</code>
									</p>
								</div>
								<!--//content-->
							</div>


							<p>To build, run:
								<code>make docker-build</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
							</p>
							<p>Once you have built your image successfully, check the output of <code>docker images</code> <i
									class="fa-duotone fa-copy fa-fw code-copy-button"></i></p>
							<pre><code>REPOSITORY                TAG       IMAGE ID       CREATED          SIZE
mattwiater/golangdocker   latest    053f21052659   10 minutes ago   26.4MB
...</code></pre>
							<p>You should see your tagged image in the list, similar to the output above.</p>
						</section>
						<!--//section-->
						<section class="docs-section" id="docker-docker-build-notes">
							<h2 class="section-heading">Docker Build notes</h2>
							<p>Using <a href="https://docs.docker.com/build/building/multi-stage/#use-multi-stage-builds">multi-stage
									builds</a>, we will use a very simple <code>Dockerfile</code> to containerize our app. Notes have been
								added here for context, the <a href="https://github.com/mwiater/golangdocker/blob/main/Dockerfile"
									target="_blank">original Dockerfile file is here</a>.
							</p>
							<pre><code># Stage 1: Use base Alpine image to prepare our binary, label it 'app'
FROM golang:alpine as app
# Add golangdocker user and group so that the Docker process in Scratch doesn't run as root
RUN addgroup -S golangdocker \
	&& adduser -S -u 10000 -g golangdocker golangdocker
# Change to the correct directory to hold our application source code
WORKDIR /go/src/app
# Copy all the files from the base of our repository to the current directory defined above
COPY . .
# Compile the application to a single statically-linked binary file
RUN CGO_ENABLED=0 go install -ldflags '-extldflags "-static"' -tags timetzdata

# Stage 2: Use the Docker Scratch image to copy our previous stage into
FROM scratch
# Grab necessary certificates as Scratch has none
COPY --from=alpine:latest /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
# Copy our binary to the root of the Scratch image (note: --from=app, the name we gave our first stage)
COPY --from=app /go/bin/golangdocker /golangdocker
# Copy the user that we created in the first stage so that we don't run the process as root
COPY --from=app /etc/passwd /etc/passwd
# Change to the non-root user
USER golangdocker
# Run our app
ENTRYPOINT ["/golangdocker"]</code></pre>


							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note: Golang compilation flags
									</h4>
									<p>Note the <strong>last</strong> line of the <strong>top</strong> section:
										<code>RUN CGO_ENABLED=0 go install -ldflags '-extldflags "-static"' -tags timetzdata</code>
										Here we are <strong>disabling CGO</strong> and using the <code>-static</code> flag. This enables Go
										to
										build a statically compiled binary, with no required additional linked files needed, and very few OS
										resources required to execute it.
									</p>
								</div>
								<!--//content-->
							</div>


							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note: Scratch is bare
									</h4>
									<p>The app could certainly be built on top of the <code>Alpine</code> image and used from that point,
										rather
										than re-building it on <code>scratch</code>. But, for this project, we only need to run a single go
										binary, we don't need all of the superfluous Alpine OS tools, allowing us to keep this image as
										small as
										possible by only including the <strong>bare minimum</strong> dependencies to run the binary in the
										container. If it was built upon the full <code>Alpine</code> image, the container would have access
										to
										common Linux commands like <code>ls</code>, <code>bash</code>, etc. This is often nice to have for
										testing, but does create minimal, unneeded overhead.
									</p>
									<p>When interactively executed with the multi-stage build, all of the common Linux OS commands are not
										required, or included. in fact, just trying to run the <code>ls</code> command on our image results
										in
										an error:
									</p>
									<p><code>docker run -it -p 5000:5000 --entrypoint ls -laF --rm mattwiater/golangdocker</code></p>
									<p>
										<code>docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: "ls": executable file not found in $PATH: unknown.</code>
									</p>
								</div>
								<!--//content-->
							</div>


							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note: Lightweight Scratch container
									</h4>
									<p>By using the <code>scratch</code> image in a multi-stage build the Docker container is as
										lightweight as possible. As of this writing, the docker binary built with the make
										<code>make golang-build</code> command is <strong>25.5MB</strong>.
									</p>

									<p>After building the Docker image with <code>make docker-build</code>, using
										<code>docker images</code> reveals that the image size is only <strong>26.6MB</strong>--very little
										overhead!
									</p>

									<pre><code>docker images

REPOSITORY                TAG       IMAGE ID       CREATED          SIZE
mattwiater/golangdocker   latest    ecfe34d443c4   23 seconds ago   <strong>26.6MB</strong></code></pre>
								</div>
								<!--//content-->
							</div>


						</section>
						<!--//section-->
						<section class="docs-section" id="docker-running-the-docker-container">
							<h2 class="section-heading">Running the Docker container</h2>
							<p>The make command below executes the following Docker command, using the <code>.env</code> variables
								you've
								defined:
							</p>
							<p>
								<code>docker run -it -p $DOCKERPORT:$SERVERPORT --rm--name golangdocker --hostname golangdocker $DOCKERIMAGE</code>
							</p>
							Env vars used in the bash script:
							<pre><code>SERVERPORT=5000
DOCKERPORT=5000
DOCKERIMAGE=mattwiater/golangdocker</code></pre>
							<p>For simplicity, the default setup above has both the application <strong>and</strong> the Docker
								container
								listening on port <strong>5000</strong>. These ports can be different. The <code>DOCKERPORT</code> var
								is
								the port
								the container listens on, and then passes the request to the <code>SERVERPORT</code> port var.
							</p>
							<p>To run the app in the container, simply run: <code>make docker-run</code> <i
									class="fa-duotone fa-copy fa-fw code-copy-button"></i></p>
							<p>You should see the default Fiber message, e.g.:</p>
							<pre><code>┌────────────────────────────────────────────────────┐
│                   Fiber v2<span class="hljs-number">.40</span><span class="hljs-number">.0</span>                    │
│               http:<span class="hljs-number">//127.0.0.1:5000                │</span> 
│       (bound on host <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> and port <span class="hljs-number">5000</span>)        │
│                                                    │
│ Handlers ............ <span class="hljs-number">14</span>  Processes ........... <span class="hljs-number">1</span>  │
│ Prefork ....... Disabled  PID ................. <span class="hljs-number">1</span>  │
└────────────────────────────────────────────────────┘
      </code></pre>
							<p>On your host machine, you can now access the container via
								<code>http://{your-host-ip-address}:5000</code>
							</p>
							<p>Our build is simple, just a compiled Go binary that runs in a container. This binary collects local
								resources/stats for display as JSON via these API Endpoints using <a
									href="https://docs.gofiber.io/">Fiber</a>:
							</p>
							<h5 id="api-info-">API Info:</h5>
							<pre><code>/api/v1</code></pre>
							<h5 id="system-info-">System Info:</h5>
							<pre><code>/api/v1/resource/
/api/v1/resource/all
/api/v1/resource/cpu
/api/v1/resource/host
/api/v1/resource/load
/api/v1/resource/memory
/api/v1/resource/network</code></pre>
							<h5 id="api-metrics-">API Metrics:</h5>
							<p>For simplicity, the default <a href="https://docs.gofiber.io/api/middleware/monitor">Fiber Monitor
									middleware</a> is included and available at:
							</p>
							<p>
							<pre><code>/api/v1/metrics</code></pre>
							</p>
							<h5 id="api-endpoint-documentation-via-swagger">API Endpoint Documentation via Swagger</h5>
							<p><code>go install github.com/swaggo/swag/cmd/swag@latest</code></p>
							<p><code>go get -u github.com/swaggo/fiber-swagger</code></p>
							<p>When updating documentation, you must run this to regenerate docs data: <code>swag init</code>
								(<code>swag init</code> is incorporated into the bash scripts for convenience, e.g.: <a
									href="https://github.com/mwiater/golangdocker/blob/main/scripts/docker_run.sh">docker_run.sh</a>)
							</p>
							<p>Then, when you run the application, docs are avaialble at:</p>
							<p><code>/api/v1/docs/index.html</code></p>
						</section>

						<section class="docs-section" id="docker-container-resource-constraints">
							<h2 class="section-heading">Docker container resource constraints</h2>
							<p>There is an important piece missing in steps above: container resource constraints. In the repository docs and scripts, we are issuing the <code>docker run</code> command without the <code>--cpus</code> or <code>--memory</code> flags. Without these flags, your container will simply try and grab as muach of the host resources as it needs. As most applications make use of multiple containers, you'll likely have multiple containers running on the same host. These containers are likely doing different tasks and requesting host resources at differing rates, so containers should be tested and constrained appropriately.</p>

							<p>For this app, I used <a href="https://github.com/ddosify/ddosify"
								target="_blank">ddosify</a> to pummel it with traffic  while testing different constraint values.</p>

							<p><code>docker run -d -p 5000:5000 --rm <strong>--cpus=1</strong> <strong>--memory=100m</strong> --name golangdocker --hostname golangdocker mattwiater/golangdocker</code></p>

							<p>My development VM has 15Gb of ram, and an 8 core processor. The CPU flag above tells the container to limit itself to 1/8 of the total CPU availability. Since I have 8 cores, I can go as high as <code>--cpus=8</code>. The memory flag is straightforward: limit the container to 100Mb of host Ram.</p>

							<p>While testing, I started these values low, and gradually increased them until the app was able to succesfully fulfill 10,000 API requests from ddosify.</p>

							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note: Load testing
									</h4>
									<p>While I'm runnnig this load test from a different host, all of this is on my local network--which is far from a real world environment. Likely, you'll have to continuously tune these values until you better understand the total load and capacity of your host system.</p>
									<p>As these values hardly work the accross all systems (bare metal, VMs, cloud services--all with different capacities), it's hard to predict what values you'll need to set, so I've left them out of my scripts.</p>
								</div>
								<!--//content-->
							</div>

							<p><code>docker run -it --rm ddosify/ddosify</code></p>

							<pre><code>       __     __              _  ____
  ____/ /____/ /____   _____ (_)/ __/__  __
 / __  // __  // __ \ / ___// // /_ / / / /
/ /_/ // /_/ // /_/ /(__  )/ // __// /_/ /
\__,_/ \__,_/ \____//____//_//_/   \__, /
                                  /____/

Simple usage: ddosify -t targetsite.com

~ #  ddosify -t http://192.168.0.99:5000/api/v1/resource/cpu -n 10000
⚙️  Initializing...
🔥 Engine fired.

🛑 CTRL+C to gracefully stop.
✔️  Successful Run: 1400   100%       ❌ Failed Run: 0        0%       ⏱️  Avg. Duration: 0.00432s
✔️  Successful Run: 2900   100%       ❌ Failed Run: 0        0%       ⏱️  Avg. Duration: 0.00468s
✔️  Successful Run: 4400   100%       ❌ Failed Run: 0        0%       ⏱️  Avg. Duration: 0.00464s
✔️  Successful Run: 5900   100%       ❌ Failed Run: 0        0%       ⏱️  Avg. Duration: 0.00469s
✔️  Successful Run: 7400   100%       ❌ Failed Run: 0        0%       ⏱️  Avg. Duration: 0.00445s
✔️  Successful Run: 8901   100%       ❌ Failed Run: 0        0%       ⏱️  Avg. Duration: 0.00445s
✔️  Successful Run: 10000  100%       ❌ Failed Run: 0        0%       ⏱️  Avg. Duration: 0.00450s


RESULT
-------------------------------------
Success Count:    10000 (100%)
Failed Count:     0     (0%)

Durations (Avg):
  DNS                  :0.0000s
  Connection           :0.0000s
  Request Write        :0.0002s
  Server Processing    :0.0041s
  Response Read        :0.0002s
  Total                :0.0045s

Status Code (Message) :Count
  200 (OK)    :10000
</code></pre>
			 
						</section>
						
						<section class="docs-section" id="docker-breakdown-running-multiple-docker-containers">
							<h2 class="section-heading">Breakdown: Running Multiple Docker Containers</h2>
							<p>As we saw above, the <code>make docker-run</code> command executes a Docker command like this:</p>
							<p>
								<code>docker run -it -p $DOCKERPORT:$SERVERPORT --rm--name golangdocker --hostname golangdocker $DOCKERIMAGE</code>
							</p>
							<p>The variables above are defined in the <code>.env</code> file. So the executed command might look like
								this after variable interpolation:</p>
							<p>
								<code>docker run -it --rm -p 5000:5000 --name golangdocker --hostname golangdocker mattwiater/golangdocker</code>
							</p>
							<p>The <code>-it</code> (interactive mode) flag is important here. When executing with this flags, Docker
								runs the container and drops you inside the container shell, rather than back out to your main shell. If
								we want to create more than one container in the same shell, we need to us the <code>-d</code>
								(detached) flag instead. This will run the container in the background, allowing you to execute other
								commands within the same session. Instead of using the script, let's create a detatched container
								manually:</p>
							<p>
								<code>docker run -d --rm -p 5000:5000 --name golangdocker01 --hostname golangdocker01 mattwiater/golangdocker</code>
							</p>
							<p>Note that we've changed the <code>--name</code> and <code>--hostname</code> (to: <stromng>
									golangdocker01</stromng>) in the above example. These can be whatever you want, but for this example,
								it makes sense to number them.</p>
							<p>Once you execute the command above, the only thnig you'll see this time is a hash (e.g.:
								<code>ce6ce3cf3907e15238e34a397ff1b30b53decfae491a1a37d2be41d08598a7d1</code>) before you are dropped
								back into your main shell. This hash is the container id. You can see this by issuing the
								<code>docker ps</code> command.
							</p>
							<pre><code>docker ps

CONTAINER ID   IMAGE                     COMMAND           CREATED          STATUS          PORTS                                       NAMES
ce6ce3cf3907   mattwiater/golangdocker   "/golangdocker"   14 seconds ago   Up 13 seconds   0.0.0.0:5000->5000/tcp, :::5000->5000/tcp   golangdocker01</code></pre>
							<p>Even though you're not in your container shell as in the previous examples, you can still access it the
								same way as before: <code>http://{your-host-ip-address}:5000</code> Now, let's start a second container,
								utilizing port <strong>5001</strong> on your <strong>host</strong> this time:</p>
							<p>
								<code>docker run -d --rm -p 5001:5000 --name golangdocker02 --hostname golangdocker02 mattwiater/golangdocker</code>
							</p>
							<p>Again, not the change of the <code>--name</code> and <code>--hostname</code> (to: <stromng>
									golangdocker02</stromng>) in the command above. These must be unique values or Docker will complain.
								Issue <code>docker ps</code> again:</p>

							<pre><code>docker ps

CONTAINER ID   IMAGE                     COMMAND           CREATED          STATUS          PORTS                                       NAMES
d7574bd0ff3c   mattwiater/golangdocker   "/golangdocker"   5 seconds ago    Up 4 seconds    0.0.0.0:5001->5000/tcp, :::5001->5000/tcp   golangdocker02
ce6ce3cf3907   mattwiater/golangdocker   "/golangdocker"   9 minutes ago    Up 9 minutes    0.0.0.0:5000->5000/tcp, :::5000->5000/tcp   golangdocker01</code></pre>

							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note
									</h4>
									<p>In the last docker run command, the host port has also been set to 5001, but the container port
										remains as 5000 (<code>:::5001->5000/tcp</code> in the output above). This is important, as the
										Docker image we built compiled the Golang app to listen on port 5000, so the container port should
										<strong>always</strong> be 5000. So the above out put tells you that your host is routing its own
										port 5000 to one Docker container, and also routing its own port 5001 to the other Docker container.
										Each Docker container recieves the request on that port, and routes it internally to the Golang app
										listening on port 5000. Since there are no internal port collisions between containers, we could
										spawn as many containers as we want, all listening internally on port 5000, <strong>as long as each
											one is assigned a unique and available host port.</strong>
									</p>
								</div>
								<!--//content-->
							</div>

							<p>Now, visit each container via a browser tab:</p>

							<p><code>http://{your-host-ip-address}:5000</code></p>
							<pre><code>{
	hostInfo: {
		hostname: "golangdocker01",
		uptime: 148851,
		bootTime: 1675121619,
		procs: 1,
		os: "linux",
		platform: "",
		platformFamily: "",
		platformVersion: "",
		kernelVersion: "5.4.0-110-generic",
		kernelArch: "x86_64",
		virtualizationSystem: "docker",
		virtualizationRole: "guest",
		hostId: "12345678-1234-5678-90ab-cddeefaabbcc"
	}
}</code></pre>

							<p><code>http://{your-host-ip-address}:5001</code></p>
							<pre><code>{
	hostInfo: {
		hostname: "golangdocker02",
		uptime: 148853,
		bootTime: 1675121619,
		procs: 1,
		os: "linux",
		platform: "",
		platformFamily: "",
		platformVersion: "",
		kernelVersion: "5.4.0-110-generic",
		kernelArch: "x86_64",
		virtualizationSystem: "docker",
		virtualizationRole: "guest",
		hostId: "12345678-1234-5678-90ab-cddeefaabbcc"
	}
}</code></pre>
							<p>To stop the containers, issue the <code>docker stop</code> command:
								<code>docker stop golangdocker01 && docker stop golangdocker02</code>
							</p>
							<p>In the above example, we are not running the containers with enforced restrictions, like limiting the
								amount of memory or CPU they can use on the host machine. See these flags (those staring with
								<code>--cpu</code> and <code>--memory</code>) and more here: <a target="_blank"
									href="https://docs.docker.com/engine/reference/commandline/run/#options">Docker Run Options</a>
								Running unrestricted containers on the same host machine is not good practice. Over time, they'll
								consume as many host resources as possible. In the <a href="#kubernetes">Kubernetes</a> section below,
								you'll see a better proctice of how to use K8s to orchestrate replicated containers accross mutiple
								nodes (hosts).
							</p>
						</section>
				</article>
				<article class="docs-article" id="tests">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-flask-vial fa-fw" style="color: #28b76b;"></i> Tests</h1>
						<section class="docs-intro">
							<p>Very simple tests are in: <a
									href="https://github.com/mwiater/golangdocker/blob/main/api_test.go">api_test.go</a></p>
						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="tests-run">
						<h2 class="section-heading">Run Tests</h2>
						<p>Run via:
							<code>clear &amp;&amp; go test -v $(go list ./... | grep -v /docs | grep -v /config | grep -v /api)</code>
							<i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
						<p>Or via Makefile:
							<code>make golang-test</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> (which will
							execute the
							<a target="_blank"
								href="https://github.com/mwiater/golangdocker/blob/main/scripts/golang_test.sh">scripts/golang_test.sh</a>
							script)
						</p>
						<pre><code>Clearing test cache...
...Complete.

Running tests...
PASS common.ExamplePrettyPrintJSONToConsole (0.00s)
PASS common.ExampleUniqueSlice (0.00s)
PASS common.ExampleSplitStringLines (0.00s)
PASS common
EMPTY .
PASS config.TestAppConfig (0.00s)
PASS config
PASS sysinfo.TestGetMemInfo (0.00s)
PASS sysinfo.TestGetCPUInfo (0.00s)
PASS sysinfo.TestGetHostInfo (0.00s)
PASS sysinfo.TestGetNetInfo (0.00s)
PASS sysinfo.TestGetLoadInfo (0.00s)
PASS sysinfo.ExampleTestTZ (0.00s)
PASS sysinfo.ExampleTestTLS (0.28s)
PASS sysinfo
PASS api.TestAPIRoutes (0.07s)
PASS api                                           
EMPTY docs

DONE 12 tests in 0.824s
...Complete.</code></pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="tests-clear-test-cache">
						<h2 class="section-heading">Clear Test Cache</h2>
						<p>While the bash script automatically clears the test cache, if you run the tests manually, you can clear
							the test cache via: <code>go clean -testcache</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
					</section>
					<!--//section-->
				</article>
				<!--//docs-article-->
				<article class="docs-article" id="linting">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-screwdriver-wrench fa-fw" style="color: #28b76b;"></i>
							Linting
						</h1>
						<section class="docs-intro">
							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note
									</h4>
									<p>This section is in progress.</p>
								</div>
								<!--//content-->
							</div>
							<p><b>To Do</b></p>
							<ul class="list-group">
								<li class="list-group-item">
									<input class="form-check-input me-1" type="checkbox" value="" id="todo01">
									<label class="form-check-label" for="todo01">Create config file <a
											href="https://golangci-lint.run/usage/configuration/">Official Docs</a></label>
								</li>
							</ul>
						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="linting-golangci-lint">
						<h2 class="section-heading">golangci-lint</h2>
						<p><code>go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<p>Usage: <code>golangci-lint run</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<p>Or via Makefile:
							<code>make golang-lint</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> (which will
							execute the
							<a target="_blank"
								href="https://github.com/mwiater/golangdocker/blob/main/scripts/golang_lint.sh">scripts/golang_lint.sh</a>
							script)
						</p>
					</section>
					<!--//section-->
				</article>
				<!--//docs-article-->
				<article class="docs-article" id="godoc">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-file-invoice fa-fw" style="color: #28b76b;"></i> Godoc</h1>
						<section class="docs-intro">
							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note
									</h4>
									<p>This section is in progress.</p>
								</div>
								<!--//content-->
							</div>
							<p>Generate and serve app documentation via <code>godoc</code>.</p>
						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="godoc-usage">
						<h2 class="section-heading">Usage</h2>
						<p><code>godoc -http=:6060</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<p>Or via Makefile:
							<code>make golang-godoc</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> (which will
							execute the
							<a target="_blank"
								href="https://github.com/mwiater/golangdocker/blob/main/scripts/golang_godoc.sh">scripts/golang_godoc.sh</a>
							script)
						</p>
						<p>Access via browser at: <code>http://{your-ip-address}:6060/pkg/{app-module-name-in-go.mod}</code></p>
						<p>E.g.: <code>http://192.168.0.91:6060/pkg/github.com/mattwiater/golangdocker/</code></p>
					</section>
					<!--//section-->
				</article>
				<!--//docs-article-->
				<article class="docs-article" id="load-testing">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-weight-hanging fa-fw" style="color: #28b76b;"></i> Load
							Testing
						</h1>
						<section class="docs-intro">
							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note
									</h4>
									<p>This section is in progress.</p>
								</div>
								<!--//content-->
							</div>
							<p>A simple local load test example using <a target="_blank"
									href="https://www.artillery.io/">Artillery</a>.</p>
							<p><b>To Do</b></p>
							<ul class="list-group">
								<li class="list-group-item">
									<input class="form-check-input me-1" type="checkbox" value="" id="todo01">
									<label class="form-check-label" for="todo01">Switch to <a href="https://github.com/ddosify/ddosify"
											target="_blank">ddosify</a>?</label>
								</li>
								<li class="list-group-item">
									<input class="form-check-input me-1" type="checkbox" value="" id="todo02">
									<label class="form-check-label" for="todo02">Explore custom metrics options in more depth.</label>
								</li>
								<li class="list-group-item">
									<input class="form-check-input me-1" type="checkbox" value="" id="todo03">
									<label class="form-check-label" for="todo03">Generate applicable reports for comparison between bare
										go app, dockerized app, and k8s replicas.</label>
								</li>
							</ul>

						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="load-testing-installation">
						<h2 class="section-heading">Installation</h2>
						<p><code>npm install -g artillery@latest</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-plugins">
						<h2 class="section-heading">Plugins</h2>
						<p><a
								href="https://www.artillery.io/docs/guides/plugins/plugin-metrics-by-endpoint#useonlyrequestnames">Official:
								Per-endpoint (URL) metrics</a>
						</p>
						<p><code>npm install artillery-plugin-metrics-by-endpoint</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-test-phases">
						<h2 class="section-heading">Test Phases</h2>
						<p>Config file: <code>golangdocker-loadtest.yml</code></p>
						<pre>
          <code>config:
 phases:
  - duration: 60
   arrivalRate: 5
   name: Warm up
  - duration: 120
   arrivalRate: 5
   rampTo: 50
   name: Ramp up load
  - duration: 600
   arrivalRate: 50
   name: Sustained load
 plugins:
  metrics-by-endpoint:
   useOnlyRequestNames: false
 processor: "custom-artillery-functions.js"
scenarios:
 - name: "golang.0nezer0.com"
  flow:

  - get:
    url: "/v1"
    afterResponse: "customMetrics"

  - get:
    url: "/v1/cpu"
    afterResponse: "customMetrics"

  - get:
    url: "/v1/host"
    capture:
     - json: "$['hostInfo']['virtualizationSystem']"
      as: "virtualizationSystem"
     - json: "$['hostInfo']['hostname']"
      as: "hostname"
    afterResponse: "customMetrics"
  # - log: "{{ hostname }} [{{ virtualizationSystem }}]" # Here to ensure we are correctly load-balancing different pods in K8s deployment

  - get:
    url: "/v1/load"
    afterResponse: "customMetrics"

  - get:
    url: "/v1/mem"
    afterResponse: "customMetrics"

  - get:
    url: "/v1/net"
    afterResponse: "customMetrics"
          </code>
          </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-custom-scripts">
						<h2 class="section-heading">Custom Scripts</h2>
						<p><strong>Artillery reference</strong>: <a
								href="https://www.artillery.io/docs/guides/guides/extension-apis#example">https://www.artillery.io/docs/guides/guides/extension-apis#example</a>
						</p>
						<p>This simple example makes use of a custom Fiber middleware wrapper that captures the time spent on the
							server in each API call and sets a <code>Server-Timing</code> response header, e.g.:
							<code>Server-Timing: route;dur=16</code>. See the <a
								href="https://github.com/mwiater/golangdocker/blob/main/api/api.go">RouteTimerHandler()</a> function
							in
							<code>api/api.go</code>.
						</p>
						<p>Custom script file: <code>golangdocker-loadtest.yml</code></p>
						<pre>
      <code>//
// custom-artillery-functions.js
//

module.exports = {
  logHeaders: logHeaders,
  customMetrics: customMetrics
}

function logHeaders(requestParams, response, context, events, next) {
  // console.log(response.headers);
  return next();
}

function customMetrics(requestParams, response, context, events, next) {
  const latency = parseServerTimingLatency(response.headers["server-timing"], "route");
  const url = new URL(requestParams.url);
  const routePath = url.pathname.replaceAll("/", "_")
  events.emit("histogram", "route_latency"+routePath.trim(), latency);
  return next();
}

function parseServerTimingLatency(header, timingMetricName) {
  const serverTimings = header.split(",");

  for (let timing of serverTimings) {
    const timingDetails = timing.split(";");
    if (timingDetails[0] === timingMetricName) {
      return parseFloat(timingDetails[1].split("=")[1]);
    }
  }
}
      </code>
      </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-load-tests">
						<h2 class="section-heading">Load Tests</h2>
						<p>In order to benchmark the different run processes, we need to start the app differently before sending a
							load test. You will also want to run these test form a different physical machine that where you&#39;re
							running the container from. Keep in mind that these are not real world load tests, as we are mostly
							testing
							to targets within the same network. These tests are mainly for comparisons of running the app with
							different mechanisms, e.g.: go app, inside Docker container, within K8s w/ replicas.
						</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-no-container-bare-app">
						<h2 class="section-heading">No container, bare app</h2>
						<p>With app running with no container, e.g.: <code>make golang-run</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i></p>
						<pre><code>clear && \
  artillery run --output golangdocker-bare.json --target http://192.168.0.91:5000/api golangdocker-loadtest.yml && \
  artillery report golangdocker-bare.json</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-docker-container">
						<h2 class="section-heading">Docker Container</h2>
						<p>With app running in Docker container, e.g.: <code>make docker-run</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i></p>
						<pre><code>clear && \
  artillery run --output golangdocker-docker.json --target http://192.168.0.91:5000/api golangdocker-loadtest.yml && \
  artillery report golangdocker-docker.json</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-kubernetes">
						<h2 class="section-heading">Kubernetes</h2>
						<p>Assumes working K8s cluster and manual scaling of replicas for each test, e.g.:</p>
						<pre><code>clear && \
  artillery run --output golangdocker-k8s-3-replica.json --target http://192.168.0.91:5000/api golangdocker-loadtest.yml && \
  artillery report golangdocker-k8s-3-replica.json</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<pre><code>clear && \
  artillery run --output golangdocker-k8s-2-replica.json --target http://192.168.0.91:5000/api golangdocker-loadtest.yml && \
  artillery report golangdocker-k8s-2-replica.json</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
					</section>
					<!--//section-->
				</article>
				<!--//docs-article-->
				<article class="docs-article" id="kubernetes">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-chart-network fa-fw" style="color: #28b76b;"></i>
							Kubernetes
						</h1>
						<section class="docs-intro">
							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note
									</h4>
									<p>This section is in progress.</p>
								</div>
								<!--//content-->
							</div>
							<p>This section walks through the high-level process of inegrating your Docker container in to your
								Kubernetes cluster. The following example will set up your Docker container to run as load-balanced
								replicas within your cluster.
							</p>
						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="kubernetes-assumptions">
						<h2 class="section-heading">Assumptions</h2>
						<p>You have built the container on the Control Plane node, e.g.:</p>
						<p>To build, run:
							<code>make docker-build</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
						<p>Once you have built your image successfully, check the output of <code>docker images</code> #=&gt;</p>
						<pre><code>REPOSITORY                TAG       IMAGE ID       CREATED          SIZE
mattwiater/golangdocker   latest    053f21052659   10 minutes ago   26.4MB
...</code></pre>
						<p>You should see your tagged image in the list, similar to the output above.</p>
						<p>Above we are going to use the <code>:v1</code> tag so that we can use <a
								href="https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/">K8s Rolling
								Updates</a>
							when we make changes to the image. If you have built images in the previous sections, you&#39;ll likely
							see
							multiple versions of your image with different tags:
						</p>
						<p><code>docker images</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<pre><code>REPOSITORY                TAG       IMAGE ID       CREATED         SIZE
mattwiater/golangdocker   latest    e9b376df3a3f   <span class="hljs-number">24</span> minutes ago  <span class="hljs-number">26.4</span>MB
mattwiater/golangdocker   v1        e9b376df3a3f   <span class="hljs-number">4</span> minutes ago   <span class="hljs-number">26.4</span>MB
...
</code></pre>
						<p>And pushed it to docker hub, e.g.: <code>docker push mattwiater/golangdocker:v1</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>

						<p>
						<div class="callout-block callout-block-info">

							<div class="content">
								<h4 class="callout-title">
									<span class="callout-icon-holder me-1">
										<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
											data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
											data-fa-i2svg="">
											<path fill="currentColor"
												d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
											</path>
										</svg><!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
									</span><!--//icon-holder-->
									Docker Hub Note
								</h4>
								<p>This step is important for the remaining nodes to download and run the image without
									having to manually build it locally on each node. K8s can use local images to spawn pods, but that
									would
									require a manual build on each node (downloading the repo, building the image, and changing the
									manifest
									entry for <code>imagePullPolicy: Always</code> to <code>imagePullPolicy: Never</code>), which we are
									skipping for this demonstration.</p>
							</div><!--//content-->
						</div>

						</p>

						<p>For rolling updates, we would just make the necessary updates to our code, build an image tagged with a
							new
							version, e.g.: <code>:v1.1</code>, <code>:v2</code>, etc., push it to docker hub, and then issue the
							command:
						</p>

						<p>
						<div class="callout-block callout-block-danger me-1">
							<div class="content">
								<h4 class="callout-title">
									<span class="callout-icon-holder">
										<svg class="svg-inline--fa fa-triangle-exclamation" aria-hidden="true" focusable="false"
											data-prefix="fas" data-icon="triangle-exclamation" role="img" xmlns="http://www.w3.org/2000/svg"
											viewBox="0 0 512 512" data-fa-i2svg="">
											<path fill="currentColor"
												d="M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z">
											</path>
										</svg><!-- <i class="fas fa-exclamation-triangle"></i> Font Awesome fontawesome.com -->
									</span><!--//icon-holder-->
									Need to fix
								</h4>
								<p><code>kubectl set image deployments/k8s-golang-api k8s-golang-api=mattwiater/golangdocker:v2</code>
									<i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
								</p>
								<p><strong>Problem</strong>: The command is not working with namespaced deployments, need to adjust. The
									command above tells K8s to update the existing deployment to the newer version and it will take care
									of bringing down the old pods and spawning new pods with no downtime.</p>
							</div><!--//content-->
						</div>
						</p>

					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-load-balancer">
						<h2 class="section-heading">Load Balancer</h2>
						<p>Since we want to make use of multiple container instances in our cluster which are accessible via a
							single external endpoint, we'll need to setup a load balancer.
						</p>
						<p>The basic traffic path is for our setup is:</p>
						<p>
							<ul>
								<li><strong>Ingress:</strong> Our domain maps to an exposed service so that we can reach the <strong>Service</strong> <i class="fa-duotone fa-angles-right"></i></li>
								<li><strong>Service:</strong> The load balancer which will route traffic from a singular endpoint to multiple Pods containers via internal
									<strong>Endpoints</strong> <i class="fa-duotone fa-angles-right"></i></li>
								<li><strong>Endpoints:</strong> Defines which target Pods to route traffic to: K8s internal pod IP Addresses and Port</li>
							</ul>
						</p>
						<p>For this example, we'll use Metal-LB to do the heavy lifting.</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-metal-lb">
						<h2 class="section-heading">Metal LB</h2>
						<p><strong>Installation</strong>: <a
								href="https://metallb.universe.tf/installation/">https://metallb.universe.tf/installation/</a>
						</p>
						<p>Ensure that Strict ARP Mode is enabled in your cluster:</p>
						<p><code>kubectl edit configmap -n kube-system kube-proxy</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<p>Edit/Add the <code>mode</code> and <code>strictARP</code> fields to match below:</p>
						<pre><code>apiVersion: kubeproxy.config.k8s.io/v1alpha1
kind: KubeProxyConfiguration
mode: "ipvs"
ipvs:
  strictARP: true</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<p>Next, set up the Metal-LB infrastructure and resources by applying the Metal-LB native Manifest via:</p>
						<p>
							<code>kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.7/config/manifests/metallb-native.yaml</code>
							<i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
						<p>Your cluster will vary, but my setup has static IP Addresses on my local network:</p>
						<p><code>kubectl get nodes</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<p>
						<pre><code>NAME STATUS ROLES AGE VERSION
mjw-udoo-01 Ready control-plane 181d v1.25.3
mjw-udoo-02 Ready worker 181d v1.25.3
mjw-udoo-03 Ready worker 181d v1.25.3
mjw-udoo-04 Ready worker 181d v1.25.3</code></pre>
						</p>
						<p>Configure Metal-LB to add these IP addresses to the IPAddressPool (REF: <a
								href="https://metallb.universe.tf/usage/example/">https://metallb.universe.tf/usage/example/</a>)</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: udoo
  namespace: metallb-system
spec:
  addresses:
  - 192.168.0.91-192.168.0.94
EOF</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<p>Then, you can name your IPAddressPool and advertise it to the cluster. In my case, I&#39;ve just named
							it
							<code>udoo</code>
						</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: metallb.io/v1beta1
kind: BGPAdvertisement
metadata:
  name: external
  namespace: metallb-system
spec:
  ipAddressPools:
  - udoo
EOF</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<p>Then, create the namespace and deployment for the App. The following code creates the
							<code>k8s-golang-api</code> namespace for the app to run in and be identified with. It is up to you to
							choose a name that makes sense, but be sure to adjust the the following YAML snippets to reflect your
							Namespave name in <em>all</em> of the <code>namespace:</code> fields.
						</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-create-namespace">
						<h2 class="section-heading">Create Namespace</h2>
						<p>Create the <code>k8s-golang-api</code> namespace to group all services, deployments, etc. Notice that all
							of
							the following YAML definitions use <code>namespace: k8s-golang-api</code> to access this new Namespace
							definition.
						</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Namespace
metadata:
  name: k8s-golang-api
EOF</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-create-deployment">
						<h2 class="section-heading">Create Deployment</h2>
						<p>The following defines how K8s will deploy the Pods on your system. It defines the names, associated
							Namespaces, number of Replicas, Resource Limits, Ports, etc.
						</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: k8s-golang-api
  namespace: k8s-golang-api
  labels:
    app: k8s-golang-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: k8s-golang-api
  template:
    metadata:
      labels:
        app: k8s-golang-api
    spec:
      containers:
        - name: k8s-golang-api
          image: 'mattwiater/golangdocker:latest'
          env:
          - name: K8S_NODE_NAME
            valueFrom:
              fieldRef:
                fieldPath: spec.nodeName
          - name: K8S_NODE_IP
            valueFrom:
              fieldRef:
                fieldPath: status.hostIP
          - name: K8S_POD_NAME
            valueFrom:
              fieldRef:
                fieldPath: metadata.name
          - name: K8S_POD_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          - name: K8S_POD_IP
            valueFrom:
              fieldRef:
                fieldPath: status.podIP
          imagePullPolicy: Always
          resources:
            requests:
              memory: "500Mi"
              cpu: "250m"
            limits:
              memory: "500Mi"

              cpu: "250m"
          ports:
            - containerPort: 5000
              protocol: TCP
EOF</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<p>The final two steps, Service and Ingress are responsible for routing external traffic into the cluster.
						</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-create-service">
						<h2 class="section-heading">Create Service</h2>
						<p>You can see that the service is accepting incoming traffic on port 80, and routing to the Pods named
							<code>k8s-golang-api</code> that are already running on Port 5000 (defined in the Deployment manifest
							above:
							<code>containerPort: 5000</code>)
						</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: k8s-golang-api
  namespace: k8s-golang-api
spec:
  type: LoadBalancer
  selector:
    app: k8s-golang-api
  ports:
  - name: web
    port: 80
    targetPort: 5000
EOF</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-create-ingress">
						<h2 class="section-heading">Create Ingress</h2>
						<p>In my setup, I want the containers to be accessible via Port 80 at the domain
							<code>golang.0nezer0.com</code>. So the Ingress section below defines the domain mapping to the Serice
							section
						</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: k8s-golang-api-ingress
  namespace: k8s-golang-api
spec:
  defaultBackend:
    service:
      name: k8s-golang-api
      port:
        number: 80
  rules:
  - host: golang.0nezer0.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: k8s-golang-api
            port:
              number: 80
EOF
</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<p>You can verify the setup via:</p>
						<p><code>kubectl describe ingress k8s-golang-api-ingress -n=k8s-golang-api</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<pre><code>Name:             k8s-golang-api-ingress
Labels:           <none>
Namespace:        k8s-golang-api
Address:
Ingress Class:    <none>
Default backend:  k8s-golang-api:80 (10.244.1.74:5000,10.244.2.104:5000,10.244.3.66:5000)
Rules:
  Host                Path  Backends
  ----                ----  --------
  golang.0nezer0.com
                      /   k8s-golang-api:80 (10.244.1.74:5000,10.244.2.104:5000,10.244.3.66:5000)
Annotations:          <none>
Events:               <none>
</code></pre>
						<p>Note that the domain is listed and the Backend are pointing to the Service we created.</p>
						<p>Ensure that you have an IP Address allocated for the Load Balancer:</p>
						<p><code>kubectl get svc -n=k8s-golang-api</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
						<pre><code>NAME             TYPE           CLUSTER-IP      EXTERNAL-IP    PORT(S)        AGE
k8s-golang-api   LoadBalancer   10.105.31.196   192.168.0.91   80:31188/TCP   21s</code></pre>
						<p>Assuming that your setup is also on your local network, make sure to add add an IP -&gt; Domain mapping
							in
							<code>/etc/hosts</code> file on the machine you are accessing the cluster from:
						</p>
						<pre><code>192<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.91</span> <span class="hljs-selector-tag">golang</span><span class="hljs-selector-class">.0nezer0</span><span class="hljs-selector-class">.com</span>
</code></pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-horizontal-pod-autoscaler">
						<h2 class="section-heading">Horizontal Pod Autoscaler (HPA)</h2>

						<p>
						<div class="callout-block callout-block-info">

							<div class="content">
								<h4 class="callout-title">
									<span class="callout-icon-holder me-1">
										<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
											data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
											data-fa-i2svg="">
											<path fill="currentColor"
												d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
											</path>
										</svg><!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
									</span><!--//icon-holder-->
									Note
								</h4>
								<p>This section needs more documentation.</p>
							</div><!--//content-->
						</div>

						</p>
						<p>
							<code>kubectl autoscale deployment -n k8s-golang-api  k8s-golang-api --cpu-percent=75 --memory-percent=75 --min=1 --max=3</code>
							<i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
					</section>
					<!--//section-->
				</article>
				<!--//docs-article-->
				<footer class="footer">
					<div class="container text-center py-5">
					</div>
				</footer>
			</div>
		</div>
	</div>
	<!--//docs-wrapper-->
	<!-- Javascript -->
	<script src="https://code.jquery.com/jquery-3.6.3.min.js"
		integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
	<script src="assets/plugins/popper.min.js"></script>
	<script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>
	<!-- Page Specific JS -->
	<script src="assets/plugins/smoothscroll.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
	<script src="assets/js/highlight-custom.js"></script>
	<script src="assets/plugins/simplelightbox/simple-lightbox.min.js"></script>
	<script src="assets/js/docs.js"></script>
	<script src="assets/js/app.js"></script>
</body>

</html>