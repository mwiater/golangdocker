<!DOCTYPE html>
<html lang="en">

<head>
	<title>GolangDocker</title>
	<!-- Meta -->
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="description" content="Bootstrap 4 Template For Software Startups">
	<meta name="author" content="Xiaoying Riley at 3rd Wave Media">
	<link rel="shortcut icon" href="favicon.ico">
	<!-- Google Font -->
	<link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">
	<!-- FontAwesome JS-->
	<script src="https://kit.fontawesome.com/5ae6879468.js" crossorigin="anonymous"></script>
	<!-- Plugins CSS -->
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/atom-one-dark.min.css">
	<link rel="stylesheet" href="assets/plugins/simplelightbox/simple-lightbox.min.css">
	<!-- Theme CSS -->
	<link id="theme-style" rel="stylesheet" href="assets/css/theme.css">
	<link id="theme-style" rel="stylesheet" href="assets/css/app.css">
</head>

<body class="docs-page">
	<header class="header fixed-top">
		<div class="branding docs-branding">
			<div class="container-fluid position-relative py-2">
				<div class="docs-logo-wrapper">
					<button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible me-2 d-xl-none"
						type="button">
						<span></span>
						<span></span>
						<span></span>
					</button>
					<div class="site-logo">
						<a class="navbar-brand" href="index.html">
							<i class="fa-duotone fa-box-check fa-fw"></i>
							<span class="logo-text"> Golang
								<span class="text-alt">Docker</span>
							</span>
						</a>
					</div>
				</div>
				<!--//docs-logo-wrapper-->
				<div style="float:right;font-size: 2em;margin-right: 20px;margin-top: 4px;"><a style="color: #000000;"
						target="_blank" href="https://github.com/mwiater/golangdocker"><i class="fa-brands fa-github"></i></a></div>
			</div>
			<!--//container-->
		</div>
		<!--//branding-->
	</header>
	<!--//header-->
	<div class="docs-wrapper">
		<div id="docs-sidebar" class="docs-sidebar">
			<nav id="docs-nav" class="docs-nav navbar">
				<ul class="section-items list-unstyled nav flex-column pb-3">
					<li class="nav-item section-title"><a class="nav-link scrollto" href="#project-motivation"><span
								class="theme-icon-holder me-2"><i class="fa-duotone fa-chalkboard-user fa-fw"></i></span>Project
							Motivation</a>
					</li>
					<li class="nav-item section-title"><a class="nav-link scrollto" href="#golang-application"><span
								class="theme-icon-holder me-2"><img style="margin-top: -4px;margin-left: -1px;"
									src="assets/images/golang-logo-green.svg" alt="logo"></span>Golang Application</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#golang-application-topics">Project Topics</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#golang-application-assumptions">Assumptions</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#golang-application-prerequisites">Prerequisites</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#golang-application-makefile">Makefile</a></li>
					<li class="nav-item"><a class="nav-link scrollto"
							href="#golang-application-testing-and-developing-app">Testing/Developing
							App</a>
					</li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#docker"><span
								class="theme-icon-holder me-2"><i class="fa-brands fa-docker fa-fw"></i></span>Docker</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#docker-building-the-docker-container">Building the
							Docker container</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#docker-docker-build-notes">Docker Build Notes</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#docker-running-the-docker-container">Running the
							Docker container</a>
					</li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#tests"><span
								class="theme-icon-holder me-2"><i class="fa-duotone fa-flask-vial fa-fw"></i></span>Tests</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#tests-run">Run</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#tests-clear-test-cache">Clear Test Cache</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#linting"><span
								class="theme-icon-holder me-2"><i
									class="fa-duotone fa-screwdriver-wrench fa-fw"></i></span></span>Linting</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#linting-golangci-lint">golangci-lint</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#godoc"><span
								class="theme-icon-holder me-2"><i class="fa-duotone fa-file-invoice fa-fw"></i></span>GoDoc</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#godoc-usage">Usage</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#load-testing"><span
								class="theme-icon-holder me-2"><i class="fa-duotone fa-weight-hanging fa-fw"></i></span>Load Testing</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-installation">Installation</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-plugins">Plugins</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-test-phases">Test Phases</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-custom-scripts">Custom Scripts</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-load-tests">Load Tests</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-no-container-bare-app">No container,
							bare app</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-docker-container">Docker container</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#load-testing-kubernetes">Kubernetes</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#kubernetes"><span
								class="theme-icon-holder me-2"><i class="fa-duotone fa-chart-network fa-fw"></i></span>Kubernetes</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-assumptions">Assumptions</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-load-balancer">Load Balancer</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-metal-lb">Metal LB</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-create-namespace">Create Namespace</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-create-deployment">Create Deployment</a>
					</li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-create-service">Create Service</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-create-ingress">Create Ingress</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#kubernetes-horizontal-pod-autoscaler">Horizontal Pod
							Autoscaler (HPA)</a>
					</li>
				</ul>
			</nav>
			<!--//docs-nav-->
		</div>
		<!--//docs-sidebar-->
		<div class="docs-content">
			<div class="container">
				<article class="docs-article" id="project-motivation">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-chalkboard-user fa-fw" style="color: #28b76b;"></i> Project
							Motivation
						</h1>
						<section class="docs-intro">
							<p>
							<h3>Why Golang?</h3>
							</p>
							<p>In my career at agencies and startups, rapid prototyping is essential. Ruby tended to by the language
								of choice for may of these projects, as it's easy to get something built quickly, and if you follow
								style guidelines, easy to read. But as these sites and apps began to scale, runtime speed, the need for
								concurrency, memory management,
								and throughput became common bottlenecks with Ruby.
							</p>
							<p>Go is a statically typed and compiled language. While not as easy as Ruby was to jump in and create
								working proof-of-concepts from the start, the fundamentals of the language made sense. Once you get the
								Go concepts and syntax down (it is not an object oriented language),
								it's easy to move forward quickly. And for a relatively young language, it has a high adoption rate and
								vast community support and feature-complete packages.
							</p>
							<p>Also, since Golang apps can be compiled into a single binary and executed with minimal OS
								resources/toolchains (See the <a href="#docker-docker-build-notes">Docker Build Notes</a> static build section below), we can create a container with a very small footprint. As shown in the tutorial,
								Go can already compile for many different target platforms as well, which makes it easy to build
								binaries for, say, both x86 and Arm architectures. </p>
							<p>
							<h3>Why Docker?</h3>
							</p>
							<p>Breaking down application components into separate, unique services allows the engineer to work within
								confined, single-purpose environments. This is in opposition to singular monoliths, where chipping away
								in one section of the code can have negative cascading consequences within the rest of the application
								due to internal dependencies. I often follow the <b><a href target="_blank"
										href="https://12factor.net/">12 Factor App</a></b> methodology, which does a great job of explaining
								the details, architecture, and reasoning behind the process.
							</p>
							<p>Using Docker properly can ease you into creating 12 Factor applications by forcing the engineer to
								think about not only breaking down an app into microservices, but also the potential application
								architecture involved. Also, by creating single purpose containers, you'll often be guided towards more
								parity with the production landscape, e.g.: different services in the AWS and Google Cloud Platform
								stacks.
							</p>
							<p>Rather than developing an app on a Linux system and using the OS as a shared resource (e.g.: running
								web and database services), splitting these into separate containers services will accomplish several
								things. Firstly, it will declare and isolate the service dependencies. Web service dependencies are
								different than Database server dependencies. When you develop on a single machine, the dependencies for
								all pieces of the application are installed with access by the underlying shared OS. When running them
								in Docker containers, these dependencies are specific to the app service inside the container.
							</p>
							<p>
							<h3>Why Kubernetes?</h3>
							</p>
							<p>As mentioned in the above Docker section, microservice architecture can be essential in building
								highly-scalable applications. The Kubernetes section will give a high-level view of the components
								involved in a K8s cluster so that the Docker container can be replicated across nodes and accessed via
								a single endpoint.
							</p>
							<p></p>
						</section>
						<!--//docs-intro-->
					</header>
				</article>
				<article class="docs-article" id="golang-application">
					<header class="docs-header">
						<h1 class="docs-heading"><img style="height: 100px;margin-top: -8px;margin-left: -15px;margin-right: -10px;"
								src="assets/images/golang-logo-green.svg" alt="logo"> Golang Application
						</h1>
						<section class="docs-intro">
							<p>This repository is a work in progress, but I'll do my best to keep the Main branch in a working
								state. Initially, this project was to create a boilerplate for containerizing Go binaries for use in a
								K8s cluster. For now, just organizing my notes in order to be able to replicate this process from
								end-to-end. The idea is to keep this narrow and succinct and be able to use this as a simple boilerplate
								for Go containers.
							</p>
						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="golang-application-topics">
						<h2 class="section-heading">Project Topics</h2>
						<p>This project is in three distinct parts, each which build on the previous:</p>
						<h5 id="1-a-simple-but-functioanl-rest-api-app-written-in-go-this-rest-api-incorporates-">1) A simple but
							functioanl rest API app written in Go. This rest API incorporates:
						</h5>
						<ul>
							<li>The <a href="https://docs.gofiber.io/api/middleware/monitor">Fiber Monitor middleware</a> (API
								endpoint:
								<code>/api/v1/metrics</code>).
							</li>
							<li>Creating and serving API documentation (using <code>swag init</code>) based on <a
									href="https://swagger.io/docs/specification/about/">Swagger specifications</a>:
								<code>/api/v1/docs/</code>).
							</li>
							<li>A <code>YAML</code> configuration pattern for setting app variables.</li>
							<li>Basic Go endpoint tests via <code>go test</code>.</li>
							<li>Building a binary of the app and embedding external files (both native compilation and
								cross-compilation
								for <code>armv6</code> as an example) so that it is portable and self contained.
							</li>
							<li>
								Go Tools
								<ul>
									<li>File formatting for *.go files using <code>gofmt</code>.</li>
									<li>Code linting for *.go files using <code>golangci-lint</code>.</li>
									<li>Code documentation via <code>godocs</code>.</li>
								</ul>
							</li>
						</ul>
						<h5 id="2-using-the-app-in-a-docker-container-covering-">2) Using the app in a Docker container, covering:
						</h5>
						<ul>
							<li><a href="https://docs.docker.com/engine/reference/commandline/build/">Docker build</a> concepts.</li>
							<li><a href="https://docs.docker.com/engine/reference/commandline/run/">Docker run</a> concepts.</li>
							<li>Docker image versioning.</li>
							<li>Ways to make use of bash scripts for repetitive tasks.</li>
						</ul>
						<h5 id="3-using-the-docker-container-in-kubernetes">3) Using the Docker container in Kubernetes</h5>
						<ul>
							<li>This section is the most incomplete, but should be in a working state.</li>
							<li>You should already have a working K8s cluster available for this section.</li>
							<li>Does not provide much background, assumes some basic knowledge using <code>kubectl</code>.</li>
							<li>This app will be deployed as a load-balanced Service across a Control Plane and 3 Worker nodes.</li>
						</ul>
					</section>
					<!--//section-->
					<section class="docs-section" id="golang-application-assumptions">
						<h2 class="section-heading">Assumptions</h2>
						<ul>
							<li><strong>IP Addresses:</strong> For the most part, disregard the hard-coded IP addresses in here (e.g.:
								my K8s cluster and VM IPs (192.168.<em>.</em>)). You&#39;ll have to sub in your own for your particular
								environment. Right now, laziness!
							</li>
							<li><strong>Container vs. Pod:</strong> I&#39;m noticing a few instances where I&#39;m using both
								<code>container</code> and <code>pod</code> to mean the same thing in the K8s section. Until I make them
								more consistent, assume they are interchangeable. A pod is basically a container in in K8s context.
								While
								a <code>pod</code> can technically have multiple containers, for this demonstration, assume a 1:1
								relationship.
							</li>
							<li><strong>System</strong> My system and architecture is below, you&#39;ll have to adjust your commands
								if
								you&#39;re departing from Linux/x86_64.
							</li>
						</ul>
						<p><code>uname -a</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<pre><code>Linux mjw-udoo-01 5.4.0-110-generic 124-Ubuntu SMP Thu Apr 14 19:46:19 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</code></pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="golang-application-prerequisites">
						<h2 class="section-heading">Prerequisites</h2>
						<p>The following programs will need to be installed:</p>
						<ul>
							<li><a href="https://go.dev/learn/">Go</a></li>
							<li><a href="https://www.docker.com/get-started/">Docker</a></li>
						</ul>
						<h4><code>.env</code> file:</h4>
						<p>The <code>.env</code> file contains the configuration for your app, and is used in the Docker build and
							run
							processes.
						</p>
						<p>
						<pre><code>SERVERPORT=5000
DOCKERPORT=5000
DEBUG=false
DOCKERIMAGE=mattwiater/golangdocker</code></pre>
						</p>
						<ul>
							<li><b>SERVERPORT:</b> The port to open for the Golang app. Value: 5000</li>
							<li><b>DOCKERPORT:</b> The port to open for Docker to map to the port above.Value: 5000</li>
							<li><b>DEBUG:</b> Turn on debugging. Value: true/false</li>
							<li><b>DOCKERIMAGE:</b> The tag for your Docker image. Value:
								<code>{your-docker-hub-account-username}/{your-docker-hub-image-name}</code> NOTE: By default, Docker
								will
								implicitly tag your image as 'latest' if no image tag is supplied. If you want to tag the image
								differently,
								adjust the <code>DOCKERIMAGE</code> env variable to include an explicit tag in the format:
								<code>{your-docker-hub-account-username}/{your-docker-hub-image-name}</code> For example, if it is a
								Version 1
								release, you might tag it <code>:v1</code>, e.g.: <code>mattwiater/golangdocker:v1</code>
							</li>
						</ul>
						<p>Required for Kubernetes itegration:</p>
						<ul>
							<li>A running <a href="https://kubernetes.io/">Kubernetes</a> cluster</li>
							<li>A <a href="https://hub.docker.com/">Docker Hub</a> account</li>
						</ul>
						<p>Optional:</p>
						<ul>
							<li>Artillery (nodejs): <a href="loadTesting.html">Load
									Testing</a>
							</li>
						</ul>
						<p>While the idea is to get this up and running quickly, it is not a deep dive into Go, Docker, or K8S.
							Basic
							knowledge of these technologies is required.
						</p>
						<p>For example, we can peek into the container via the API endpoint <code>api/v1/host</code> and see the
							docker assigned <code>hostname: &quot;b189564db0c5&quot;</code> and verify that it is one running a single
							process <code>procs: 1</code>:
						</p>
						<pre><code>{
  hostInfo: {
    hostname: "b189564db0c5",
    uptime: 1238849,
    bootTime: 1667920883,
    procs: 1,
    os: "linux",
    platform: "",
    platformFamily: "",
    platformVersion: "",
    kernelVersion: "5.4.0-110-generic",
    kernelArch: "x86_64",
    virtualizationSystem: "docker",
    virtualizationRole: "guest",
    hostId: "12345678-1234-5678-90ab-cddeefaabbcc"
    }
  }
</code></pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="golang-application-makefile">
						<h2 class="section-heading">Makefile</h2>
						<p>[IN PROGRESS]</p>
						<p>There is a <a target="_blank"
								href="https://github.com/mwiater/golangdocker/blob/main/Makefile">Makefile</a>
							for convenience. At the moment, it&#39;s just acting as a script-runner.
							To view the executable targets, just type: <code>make</code>
						</p>
						<pre><code>Targets in this Makefile:

docker-build
docker-run
golang-build
golang-build-arm64
golang-run</code></pre>
						<p>The bash scripts executed by the Makefile live in the <a target="_blank"
								href="https://github.com/mwiater/golangdocker/tree/main/scripts">/scripts</a> directory.</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="golang-application-testing-and-developing-app">
						<h2 class="section-heading">Testing/Developing App</h2>
						<p>while developing/testing the app, you can run it natively (not in a Docker container) via:</p>
						<p><code>go run main.go</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i></p>
						<p>Or, for convenience, run: <code>make golang-run</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
						<p>Site will be available at: <a href="http://192.168.0.91:5000/api/v1">http://192.168.0.91:5000/api/v1</a>
							(substitute your own IP address)
						</p>
						<p>This step should be completed first before running via Docker to ensure everything is working properly.
						</p>
					</section>
					<!--//section-->
				</article>
				<article class="docs-article" id="docker">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-brands fa-docker fa-fw" style="color: #28b76b;"></i>
							Docker
						</h1>
						<section class="docs-intro">
							<p>In this section, we will take our working application binary and wrap it in a bare-minimum Docker
								container.
							</p>
							<p>For installation on your system, see the <a href="https://docs.docker.com/get-docker/">official
									documentation</a>.
							</p>
						</section>
						<section class="docs-section" id="docker-building-the-docker-container">
							<h2 id="building-the-docker-container">Building the Docker container</h2>
							<p>NOTE: The steps will refer to the docker image: <code>mattwiater/golangdocker</code>. You should change
								these steps to match your own image name in the <code>.env</code> file, e.g.:
								<code>DOCKERIMAGE={your-docker-hub-account-username}/golangdocker</code>
							</p>
							<p>To build, run:
								<code>make docker-build</code>
							</p>
							<p>Once you have built your image successfully, check the output of <code>docker images</code> #=&gt;</p>
							<pre><code>REPOSITORY                TAG       IMAGE ID       CREATED          SIZE
mattwiater/golangdocker   latest    053f21052659   10 minutes ago   10.7MB
...</code></pre>
							<p>You should see your tagged image in the list, similar to the output above.</p>
						</section>
						<!--//section-->
						<section class="docs-section" id="docker-docker-build-notes">
							<h2 class="section-heading">Docker Build notes</h2>
							<p>Using <a href="https://docs.docker.com/build/building/multi-stage/#use-multi-stage-builds">multi-stage
									builds</a>, we will use a very simple <code>Dockerfile</code> to containerize our app.
							</p>
							<pre><code>FROM golang:alpine as app
WORKDIR /go/src/app
COPY . .
RUN apk add git
RUN CGO_ENABLED=0 go install -ldflags '-extldflags "-static"' -tags timetzdata
    
FROM scratch
COPY --from=app /go/bin/golangdocker /golangdocker
COPY --from=alpine:latest /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
ENTRYPOINT ["/golangdocker"]</code></pre>
							<p>The above represents a multi-stage build Dockerfile. The <strong>top</strong> section uses the base
								Golang Alpine image to copy
								the app files and install required packages, like <code>timetzdata</code>. Using the <code>Alpine</code>
								image for the initial stage ensure that the image is built on a full working OS. This is important as
								were
								using the Docker <code>scratch</code> image in the subsequent step, which contains no OS, toolchains,
								etc.
								In this step, all of the toolchains required to build a go app are in the base <code>Alpine</code>
								image.
								Note the <strong>last</strong> line of the <strong>top</strong> section:
								<code>RUN CGO_ENABLED=0 go install -ldflags '-extldflags "-static"' -tags timetzdata</code>
								Here we are <strong>disabling CGO</strong> and using the <code>-static</code> flag. This enables Go to
								build a statically compiled binary, with no required additional linked files needed, and very few OS
								resources required to execute it.
							</p>
							<p>The <strong>bottom</strong> section uses the Docker <code>scratch</code> image (a completely empty
								image). It includes the top
								<code>app</code> section into the image (all of the minimal artifacts used to generate the app binary),
								as
								well as installing some fundamentals, like the certs from the <code>Alpine</code> image.
							</p>
							<p>The app could certainly be built on top of the <code>Alpine</code> image and used from that point,
								rather
								than re-building it on <code>scratch</code>. But, for this project, we only need to run a single go
								binary, we don't need all of the superfluous Alpine OS tools, allowing us to keep this image as small as
								possible by only including the <strong>bare minimum</strong> dependencies to run the binary in the
								container. If it was built upon the full <code>Alpine</code> image, the container would have access to
								common linux commands like <code>ls</code>, <code>bash</code>, etc. This is often nice to have for
								testing, but does create minimal, unneeded overhead.
							</p>
							<p>When interactively executed with the multi-stage build, all of the common linux OS commands are not
								requireed, or included. in fact, just trying to run the <code>ls</code> command on our image results in
								an error:
							</p>
							<p><code>docker run -it -p 5000:5000 --entrypoint ls -laF --rm mattwiater/golangdocker`</code></p>
							<p>
								<code>docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: "ls": executable file not found in $PATH: unknown.</code>
							</p>
						</section>
						<!--//section-->
						<section class="docs-section" id="docker-running-the-docker-container">
							<h2 class="section-heading">Running the Docker container</h2>
							<p>The make command below executes the following Docker command, using the <code>.env</code> variables
								you've
								defined:
							</p>
							<p><code>docker run -it -p $DOCKERPORT:$SERVERPORT --rm $DOCKERIMAGE</code></p>
							Env vars used in the bash script:
							<pre><code>SERVERPORT=5000
DOCKERPORT=5000
DOCKERIMAGE=mattwiater/golangdocker</code></pre>
							<p>For simplicity, the default setup above has both the application <strong>and</strong> the Docker
								container
								listening on port <strong>5000</strong>. These ports can be different. The <code>DOCKERPORT</code> var
								is
								the port
								the container listens on, and then passes the request to the <code>SERVERPORT</code> port var.
							</p>
							<p>To run the app in the container, simply run: <code>make docker-run</code></p>
							<p>You should see the default Fiber message, e.g.:</p>
							<pre><code>┌────────────────────────────────────────────────────┐
│                   Fiber v2<span class="hljs-number">.40</span><span class="hljs-number">.0</span>                    │
│               http:<span class="hljs-number">//127.0.0.1:5000                │</span> 
│       (bound on host <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> and port <span class="hljs-number">5000</span>)        │
│                                                    │
│ Handlers ............ <span class="hljs-number">14</span>  Processes ........... <span class="hljs-number">1</span>  │
│ Prefork ....... Disabled  PID ................. <span class="hljs-number">1</span>  │
└────────────────────────────────────────────────────┘
      </code></pre>
							<p>On your host machine, you can now access the container via
								<code>http://{your-host-ip-address}:5000</code>
							</p>
							<p>Our build is simple, just a compiled Go binary that runs in a container. This binary collects local
								resources/stats for display as JSON via these API Endpoints using <a
									href="https://docs.gofiber.io/">Fiber</a>:
							</p>
							<h5 id="api-info-">API Info:</h5>
							<pre>http://{your-host-ip-address}:5000/api/v1</pre>
							<h5 id="system-info-">System Info:</h5>
							<pre>http://{your-host-ip-address}:5000/api/v1/mem
http://{your-host-ip-address}:5000/api/v1/cpu
http://{your-host-ip-address}:5000/api/v1/host
http://{your-host-ip-address}:5000/api/v1/net
http://{your-host-ip-address}:5000/api/v1/load
      </pre>
							<h5 id="api-metrics-">API Metrics:</h5>
							<p>For simplicity, the default <a href="https://docs.gofiber.io/api/middleware/monitor">Fiber Monitor
									middleware</a> is included and available at:
							</p>
							<p><code>http://{your-host-ip-address}:5000/api/v1/metrics</code></p>
							<h5 id="api-endpoint-documentation-via-swagger">API Endpoint Documentation via Swagger</h5>
							<p><code>go install github.com/swaggo/swag/cmd/swag@latest</code></p>
							<p><code>go get -u github.com/swaggo/fiber-swagger</code></p>
							<p>When updating documentation, you must run this to regenerate docs data: <code>swag init</code>
								(<code>swag init</code> is incorporated into the bash scripts for convenience, e.g.: <a
									href="https://github.com/mwiater/golangdocker/blob/main/scripts/docker_run.sh">docker_run.sh</a>)
							</p>
							<p>Then, when you run the application, docs are avaialble at:</p>
							<p><code>http://{your-host-ip-address}:5000/api/v1/docs/index.html</code></p>
						</section>
						<!--//section-->
				</article>
				<article class="docs-article" id="tests">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-flask-vial fa-fw" style="color: #28b76b;"></i> Tests</h1>
						<section class="docs-intro">
							<p>Very simple tests are in: <a
									href="https://github.com/mwiater/golangdocker/blob/main/api_test.go">api_test.go</a></p>
						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="tests-run">
						<h2 class="section-heading">Run Tests</h2>
						<p>Run via:
							<code>clear &amp;&amp; go test -v $(go list ./... | grep -v /docs | grep -v /config | grep -v /api)</code>
							<i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
						<p>Or via Makefile:
							<code>make golang-test</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> (which will
							execute the
							<a target="_blank"
								href="https://github.com/mwiater/golangdocker/blob/main/scripts/golang_test.sh">scripts/golang_test.sh</a>
							script)
						</p>
						<pre><code>=== RUN   TestAPIRoutes
      
┌───────────────────────────────────────────────────┐
│                   Fiber v2.40.1                   │
│               http://127.0.0.1:5000               │
│       (bound on host 0.0.0.0 and port 5000)       │
│                                                   │
│ Handlers ............ 22  Processes ........... 1 │
│ Prefork ....... Disabled  PID ........... 2214242 │
└───────────────────────────────────────────────────┘

[2022-12-13T11:01:06] GET:/: 302 (     0s) | Bytes In: 0 Bytes Out: 0
[2022-12-13T11:01:06] GET:/api/v1: 200 (     0s) | Bytes In: 0 Bytes Out: 136
[2022-12-13T11:01:06] GET:/api/v1/cpu: 200 (    1ms) | Bytes In: 0 Bytes Out: 3593
[2022-12-13T11:01:06] GET:/api/v1/host: 200 (    1ms) | Bytes In: 0 Bytes Out: 338
[2022-12-13T11:01:06] GET:/api/v1/load: 200 (     0s) | Bytes In: 0 Bytes Out: 54
[2022-12-13T11:01:06] GET:/api/v1/mem: 200 (    1ms) | Bytes In: 0 Bytes Out: 706
[2022-12-13T11:01:06] GET:/api/v1/net: 200 (    2ms) | Bytes In: 0 Bytes Out: 1559
[2022-12-13T11:01:06] GET:/api/v1/metrics: 200 (     0s) | Bytes In: 0 Bytes Out: 6186
[2022-12-13T11:01:06] GET:/api/v1/docs/index.html: 200 (     0s) | Bytes In: 0 Bytes Out: 3519
[2022-12-13T11:01:06] GET:/api/v1/404: 404 (     0s) | Bytes In: 0 Bytes Out: 22
--- PASS: TestAPIRoutes (0.13s)
PASS
ok      github.com/mattwiater/golangdocker      0.190s
=== RUN   ExamplePrettyPrintJSONToConsole
--- PASS: ExamplePrettyPrintJSONToConsole (0.00s)
=== RUN   ExampleUniqueSlice
--- PASS: ExampleUniqueSlice (0.00s)
PASS
ok      github.com/mattwiater/golangdocker/common       0.005s
=== RUN   ExampleTestTZ
--- PASS: ExampleTestTZ (0.00s)
=== RUN   ExampleTestTLS
--- PASS: ExampleTestTLS (0.35s)
PASS
ok      github.com/mattwiater/golangdocker/sysinfo      0.365s
      </code></pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="tests-clear-test-cache">
						<h2 class="section-heading">Clear Test Cache</h2>
						<p>To clear the test cache, run: <code>go clean -testcache</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
					</section>
					<!--//section-->
				</article>
				<!--//docs-article-->
				<article class="docs-article" id="linting">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-screwdriver-wrench fa-fw" style="color: #28b76b;"></i>
							Linting
						</h1>
						<section class="docs-intro">
							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note
									</h4>
									<p>This section is in progress.</p>
								</div>
								<!--//content-->
							</div>
							<p><b>To Do</b></p>
							<ul>
								<li>Create config file <a href="https://golangci-lint.run/usage/configuration/">Official Docs</a></li>
							</ul>
						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="linting-golangci-lint">
						<h2 class="section-heading">golangci-lint</h2>
						<p><code>go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<p>Usage: <code>golangci-lint run</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<p>Or via Makefile:
							<code>make golang-lint</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> (which will
							execute the
							<a target="_blank"
								href="https://github.com/mwiater/golangdocker/blob/main/scripts/golang_lint.sh">scripts/golang_lint.sh</a>
							script)
						</p>
					</section>
					<!--//section-->
				</article>
				<!--//docs-article-->
				<article class="docs-article" id="godoc">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-file-invoice fa-fw" style="color: #28b76b;"></i> Godoc</h1>
						<section class="docs-intro">
							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note
									</h4>
									<p>This section is in progress.</p>
								</div>
								<!--//content-->
							</div>
							<p>Generate and serve app documentation via <code>godoc</code>.</p>
						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="godoc-usage">
						<h2 class="section-heading">Usage</h2>
						<p><code>godoc -http=:6060</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<p>Or via Makefile:
							<code>make golang-godoc</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> (which will
							execute the
							<a target="_blank"
								href="https://github.com/mwiater/golangdocker/blob/main/scripts/golang_godoc.sh">scripts/golang_godoc.sh</a>
							script)
						</p>
						<p>Access via browser at: <code>http://{your-ip-address}:6060/pkg/{app-module-name-in-go.mod}</code></p>
						<p>E.g.: <code>http://192.168.0.91:6060/pkg/github.com/mattwiater/golangdocker/</code></p>
					</section>
					<!--//section-->
				</article>
				<!--//docs-article-->
				<article class="docs-article" id="load-testing">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-weight-hanging fa-fw" style="color: #28b76b;"></i> Load
							Testing
						</h1>
						<section class="docs-intro">
							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note
									</h4>
									<p>This section is in progress.</p>
								</div>
								<!--//content-->
							</div>
							<p>A simple local load test example using <a target="_blank"
									href="https://www.artillery.io/">Artillery</a>.</p>
							<p><b>To Do</b></p>
							<ul>
								<li>Explore custom metrics options in more depth.</li>
								<li>Generate applicable reports for comparison between bare go app, dockerized app, and k8s replicas.
								</li>
							</ul>
						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="load-testing-installation">
						<h2 class="section-heading">Installation</h2>
						<p><code>npm install -g artillery@latest</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-plugins">
						<h2 class="section-heading">Plugins</h2>
						<p><a
								href="https://www.artillery.io/docs/guides/plugins/plugin-metrics-by-endpoint#useonlyrequestnames">Official:
								Per-endpoint (URL) metrics</a>
						</p>
						<p><code>npm install artillery-plugin-metrics-by-endpoint</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-test-phases">
						<h2 class="section-heading">Test Phases</h2>
						<p>Config file: <code>golangdocker-loadtest.yml</code></p>
						<pre>
          <code>config:
 phases:
  - duration: 60
   arrivalRate: 5
   name: Warm up
  - duration: 120
   arrivalRate: 5
   rampTo: 50
   name: Ramp up load
  - duration: 600
   arrivalRate: 50
   name: Sustained load
 plugins:
  metrics-by-endpoint:
   useOnlyRequestNames: false
 processor: "custom-artillery-functions.js"
scenarios:
 - name: "golang.0nezer0.com"
  flow:

  - get:
    url: "/v1"
    afterResponse: "customMetrics"

  - get:
    url: "/v1/cpu"
    afterResponse: "customMetrics"

  - get:
    url: "/v1/host"
    capture:
     - json: "$['hostInfo']['virtualizationSystem']"
      as: "virtualizationSystem"
     - json: "$['hostInfo']['hostname']"
      as: "hostname"
    afterResponse: "customMetrics"
  # - log: "{{ hostname }} [{{ virtualizationSystem }}]" # Here to ensure we are correctly load-balancing different pods in K8s deployment

  - get:
    url: "/v1/load"
    afterResponse: "customMetrics"

  - get:
    url: "/v1/mem"
    afterResponse: "customMetrics"

  - get:
    url: "/v1/net"
    afterResponse: "customMetrics"
          </code>
          </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-custom-scripts">
						<h2 class="section-heading">Custom Scripts</h2>
						<p>Reference: <a
								href="https://www.artillery.io/docs/guides/guides/extension-apis#example">https://www.artillery.io/docs/guides/guides/extension-apis#example</a>
						</p>
						<p>This simple example makes use of a custom Fiber middleware wrapper that captures the time spent on the
							server in each API call and sets a <code>Server-Timing</code> response header, e.g.:
							<code>Server-Timing: route;dur=16</code>. See the <a
								href="https://github.com/mwiater/golangdocker/blob/main/api/api.go">RouteTimerHandler()</a> function
							in
							<code>api/api.go</code>.
						</p>
						<p>Custom script file: <code>golangdocker-loadtest.yml</code></p>
						<pre>
      <code>//
// custom-artillery-functions.js
//

module.exports = {
  logHeaders: logHeaders,
  customMetrics: customMetrics
}

function logHeaders(requestParams, response, context, events, next) {
  // console.log(response.headers);
  return next();
}

function customMetrics(requestParams, response, context, events, next) {
  const latency = parseServerTimingLatency(response.headers["server-timing"], "route");
  const url = new URL(requestParams.url);
  const routePath = url.pathname.replaceAll("/", "_")
  events.emit("histogram", "route_latency"+routePath.trim(), latency);
  return next();
}

function parseServerTimingLatency(header, timingMetricName) {
  const serverTimings = header.split(",");

  for (let timing of serverTimings) {
    const timingDetails = timing.split(";");
    if (timingDetails[0] === timingMetricName) {
      return parseFloat(timingDetails[1].split("=")[1]);
    }
  }
}
      </code>
      </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-load-tests">
						<h2 class="section-heading">Load Tests</h2>
						<p>In order to benchmark the different run processes, we need to start the app differently before sending a
							load test. You will also want to run these test form a different physical machine that where you&#39;re
							running the container from. Keep in mind that these are not real world load tests, as we are mostly
							testing
							to targets within the same network. These tests are mainly for comparisons of running the app with
							different mechanisms, e.g: go app, inside Docker container, within K8s w/ replicas.
						</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-no-container-bare-app">
						<h2 class="section-heading">No container, bare app</h2>
						<p>With app running with no container, e.g.: <code>make golang-run</code></p>
						<pre><code>clear && \
  artillery run --output golangdocker-bare.json --target http://192.168.0.91:5000/api golangdocker-loadtest.yml && \
  artillery report golangdocker-bare.json</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-docker-container">
						<h2 class="section-heading">Docker Container</h2>
						<p>With app running in Docker container, e.g.: <code>make docker-run</code></p>
						<pre><code>clear && \
  artillery run --output golangdocker-docker.json --target http://192.168.0.91:5000/api golangdocker-loadtest.yml && \
  artillery report golangdocker-docker.json</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="load-testing-kubernetes">
						<h2 class="section-heading">Kubernetes</h2>
						<p>Assumes working K8s cluster and manual scaling of replicas for each test, e.g.:</p>
						<pre><code>clear && \
  artillery run --output golangdocker-k8s-3-replica.json --target http://192.168.0.91:5000/api golangdocker-loadtest.yml && \
  artillery report golangdocker-k8s-3-replica.json</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<pre><code>clear && \
  artillery run --output golangdocker-k8s-2-replica.json --target http://192.168.0.91:5000/api golangdocker-loadtest.yml && \
  artillery report golangdocker-k8s-2-replica.json</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
					</section>
					<!--//section-->
				</article>
				<!--//docs-article-->
				<article class="docs-article" id="kubernetes">
					<header class="docs-header">
						<h1 class="docs-heading"><i class="fa-duotone fa-chart-network fa-fw" style="color: #28b76b;"></i>
							Kubernetes
						</h1>
						<section class="docs-intro">
							<div class="callout-block callout-block-info">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<svg class="svg-inline--fa fa-circle-info" aria-hidden="true" focusable="false" data-prefix="fas"
												data-icon="circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"
												data-fa-i2svg="">
												<path fill="currentColor"
													d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 128c17.67 0 32 14.33 32 32c0 17.67-14.33 32-32 32S224 177.7 224 160C224 142.3 238.3 128 256 128zM296 384h-80C202.8 384 192 373.3 192 360s10.75-24 24-24h16v-64H224c-13.25 0-24-10.75-24-24S210.8 224 224 224h32c13.25 0 24 10.75 24 24v88h16c13.25 0 24 10.75 24 24S309.3 384 296 384z">
												</path>
											</svg>
											<!-- <i class="fas fa-info-circle"></i> Font Awesome fontawesome.com -->
										</span>
										<!--//icon-holder-->
										Note
									</h4>
									<p>This section is in progress.</p>
								</div>
								<!--//content-->
							</div>
							<p>This section walks through the high-level process of inegrating your Docker container in to your
								Kubernetes cluster. The following example will set up your Docker container to run as load-balanced
								replicas within your cluster.
							</p>
						</section>
						<!--//docs-intro-->
					</header>
					<section class="docs-section" id="kubernetes-assumptions">
						<h2 class="section-heading">Assumptions</h2>
						<p>You have built the container on the Control Plane node, e.g.:</p>
						<p>To build, run:
							<code>make docker-build</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
						<p>Once you have built your image successfully, check the output of <code>docker images</code> #=&gt;</p>
						<pre><code>REPOSITORY                TAG       IMAGE ID       CREATED          SIZE
mattwiater/golangdocker   latest    053f21052659   10 minutes ago   10.7MB
...</code></pre>
						<p>You should see your tagged image in the list, similar to the output above.</p>
						<p>Above we are going to use the <code>:v1</code> tag so that we can use <a
								href="https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/">K8s Rolling
								Updates</a>
							when we make changes to the image. If you have built images in the previous sections, you&#39;ll likely
							see
							multiple versions of your image with different tags:
						</p>
						<p><code>docker images</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<pre><code>REPOSITORY                TAG       IMAGE ID       CREATED         SIZE
mattwiater/golangdocker   latest    e9b376df3a3f   <span class="hljs-number">24</span> minutes ago  <span class="hljs-number">11.1</span>MB
mattwiater/golangdocker   v1        e9b376df3a3f   <span class="hljs-number">4</span> minutes ago   <span class="hljs-number">11.1</span>MB
...
</code></pre>
						<p>And pushed it to docker hub, e.g.: <code>docker push mattwiater/golangdocker:v1</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<p>Docker Hub Note: This step is important for the remaining nodes to download and run the image without
							having to manually build it locally on each node. K8s can use local images to spawn pods, but that would
							require a manual build on each node (downloading the repo, building the image, and changing the manifest
							entry for <code>imagePullPolicy: Always</code> to <code>imagePullPolicy: Never</code>), which we are
							skipping for this demonstration.
						</p>
						<p>For rolling updates, we would just make the necessary updates to our code, build an image tagged with a
							new
							version, e.g.: <code>:v1.1</code>, <code>:v2</code>, etc., push it to docker hub, and then issue the
							command:
						</p>
						<p>[NEED TO FIX]:
							<code>kubectl set image deployments/k8s-golang-api k8s-golang-api=mattwiater/golangdocker:v2</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
						<p>[PROBLEM]: The command is not working with namespaced deployments, need to adjust.</p>
						<p>The command above tells K8s to update the existing deployment to the newer version and it will take care
							of
							bringing down the old pods and spawning new pods with no downtime.
						</p>
						<p>[TO DO: Need example after the initial deployment below is complete]</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-load-balancer">
						<h2 class="section-heading">Load Balancer</h2>
						<p>Since we want to make use of multiple container instances in our cluster which are accessible via a
							single external endpoint, we'll need to setup a load balancer.
						</p>
						<p>The basic traffic path is for our setup is:</p>
						<p>Ingress: Our domain maps to an exposed service so that we can reach the Service Service: The load
							balancer which will route traffic from a singular endpoint to multiple Pods containers via internal
							Endpoints Endpoints: Defines which target Pods to route traffic to: internal IP Address and Port
						</p>
						<p>For this example, we'll use Metal-LB to do the heavy lifting.</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-metal-lb">
						<h2 class="section-heading">Metal LB</h2>
						<p>METAL-LB: <a
								href="https://metallb.universe.tf/installation/">https://metallb.universe.tf/installation/</a>
						</p>
						<p>Ensure that Strict ARP Mode is enabled in your cluster:</p>
						<p><code>kubectl edit configmap -n kube-system kube-proxy</code></p>
						<p>Edit/Add the <code>mode</code> and <code>strictARP</code> fields to match below:</p>
						<pre><code>apiVersion: kubeproxy.config.k8s.io/v1alpha1
kind: KubeProxyConfiguration
mode: "ipvs"
ipvs:
  strictARP: true</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<p>Next, set up the Metal-LB infrastructure and resources by applying the Metal-LB native Manifest via:</p>
						<p>
							<code>kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.13.7/config/manifests/metallb-native.yaml</code>
						</p>
						<p>Your cluster will vary, but my setup has static IP Addresses on my local network:</p>
						<p><code>kubectl get nodes</code></p>
						<p>
						<pre><code>NAME STATUS ROLES AGE VERSION
mjw-udoo-01 Ready control-plane 181d v1.25.3
mjw-udoo-02 Ready worker 181d v1.25.3
mjw-udoo-03 Ready worker 181d v1.25.3
mjw-udoo-04 Ready worker 181d v1.25.3</code></pre>
						</p>
						<p>Configure Metal-LB to add these IP addresses to the IPAddressPool (REF: <a
								href="https://metallb.universe.tf/usage/example/">https://metallb.universe.tf/usage/example/</a>)</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: udoo
  namespace: metallb-system
spec:
  addresses:
  - 192.168.0.91-192.168.0.94
EOF</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<p>Then, you can name your IPAddressPool and advertise it to the cluster. In my case, I&#39;ve just named
							it
							<code>udoo</code>
						</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: metallb.io/v1beta1
kind: BGPAdvertisement
metadata:
  name: external
  namespace: metallb-system
spec:
  ipAddressPools:
  - udoo
EOF</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<p>Then, create the namespace and deployment for the App. The following code creates the
							<code>k8s-golang-api</code> namespace for the app to run in and be identified with. It is up to you to
							choose a name that makes sense, but be sure to adjust the the following YAML snippets to reflect your
							Namespave name in <em>all</em> of the <code>namespace:</code> fields.
						</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-create-namespace">
						<h2 class="section-heading">Create Namespace</h2>
						<p>Create the <code>k8s-golang-api</code> namespace to group all services, deployments, etc. Notice that all
							of
							the following YAML definitions use <code>namespace: k8s-golang-api</code> to access this new Namespace
							definition.
						</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Namespace
metadata:
  name: k8s-golang-api
EOF</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-create-deployment">
						<h2 class="section-heading">Create Deployment</h2>
						<p>The following defines how K8s will deploy the Pods on your system. It defines the names, associated
							Namespaces, number of Replicas, Resource Limits, Ports, etc.
						</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: k8s-golang-api
  namespace: k8s-golang-api
  labels:
    app: k8s-golang-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: k8s-golang-api
  template:
    metadata:
      labels:
        app: k8s-golang-api
    spec:
      containers:
        - name: k8s-golang-api
          image: 'mattwiater/golangdocker:latest'
          env:
          - name: K8S_NODE_NAME
            valueFrom:
              fieldRef:
                fieldPath: spec.nodeName
          - name: K8S_NODE_IP
            valueFrom:
              fieldRef:
                fieldPath: status.hostIP
          - name: K8S_POD_NAME
            valueFrom:
              fieldRef:
                fieldPath: metadata.name
          - name: K8S_POD_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          - name: K8S_POD_IP
            valueFrom:
              fieldRef:
                fieldPath: status.podIP
          imagePullPolicy: Always
          resources:
            requests:
              memory: "500Mi"
              cpu: "250m"
            limits:
              memory: "500Mi"

              cpu: "250m"
          ports:
            - containerPort: 5000
              protocol: TCP
EOF</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<p>The final two steps, Service and Ingress are responsible for routing external traffic into the cluster.
						</p>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-create-service">
						<h2 class="section-heading">Create Service</h2>
						<p>You can see that the service is accepting incoming traffic on port 80, and routing to the Pods named
							<code>k8s-golang-api</code> that are already running on Port 5000 (defined in the Deployment manifest
							above:
							<code>containerPort: 5000</code>)
						</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: k8s-golang-api
  namespace: k8s-golang-api
spec:
  type: LoadBalancer
  selector:
    app: k8s-golang-api
  ports:
  - name: web
    port: 80
    targetPort: 5000
EOF</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-create-ingress">
						<h2 class="section-heading">Create Ingress</h2>
						<p>In my setup, I want the containers to be accessible via Port 80 at the domain
							<code>golang.0nezer0.com</code>. So the Ingress section below defines the domain mapping to the Serice
							section
						</p>
						<pre><code>cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: k8s-golang-api-ingress
  namespace: k8s-golang-api
spec:
  defaultBackend:
    service:
      name: k8s-golang-api
      port:
        number: 80
  rules:
  - host: golang.0nezer0.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: k8s-golang-api
            port:
              number: 80
EOF
</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i> </pre>
						<p>You can verify the setup via:</p>
						<p><code>kubectl describe ingress k8s-golang-api-ingress -n=k8s-golang-api</code> <i
								class="fa-duotone fa-copy fa-fw code-copy-button"></i> </p>
						<pre><code>Name:             k8s-golang-api-ingress
Labels:           <none>
Namespace:        k8s-golang-api
Address:
Ingress Class:    <none>
Default backend:  k8s-golang-api:80 (10.244.1.74:5000,10.244.2.104:5000,10.244.3.66:5000)
Rules:
  Host                Path  Backends
  ----                ----  --------
  golang.0nezer0.com
                      /   k8s-golang-api:80 (10.244.1.74:5000,10.244.2.104:5000,10.244.3.66:5000)
Annotations:          <none>
Events:               <none>
</code></pre>
						<p>Note that the domain is listed and the Backend are pointing to the Service we created.</p>
						<p>Ensure that you have an IP Address allocated for the Load Balancer:</p>
						<p><code>kubectl get svc -n=k8s-golang-api</code> <i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
						<pre><code>NAME             TYPE           CLUSTER-IP      EXTERNAL-IP    PORT(S)        AGE
k8s-golang-api   LoadBalancer   10.105.31.196   192.168.0.91   80:31188/TCP   21s</code></pre>
						<p>Assuming that your setup is also on your local network, make sure to add add an IP -&gt; Domain mapping
							in
							<code>/etc/hosts</code> file on the machine you are accessing the cluster from:
						</p>
						<pre><code>192<span class="hljs-selector-class">.168</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.91</span> <span class="hljs-selector-tag">golang</span><span class="hljs-selector-class">.0nezer0</span><span class="hljs-selector-class">.com</span>
</code></pre>
					</section>
					<!--//section-->
					<section class="docs-section" id="kubernetes-horizontal-pod-autoscaler">
						<h2 class="section-heading">Horizontal Pod Autoscaler (HPA)</h2>
						<p>
							<code>kubectl autoscale deployment -n k8s-golang-api  k8s-golang-api --cpu-percent=75 --memory-percent=75 --min=1 --max=3</code>
							<i class="fa-duotone fa-copy fa-fw code-copy-button"></i>
						</p>
					</section>
					<!--//section-->
				</article>
				<!--//docs-article-->
				<footer class="footer">
					<div class="container text-center py-5">
					</div>
				</footer>
			</div>
		</div>
	</div>
	<!--//docs-wrapper-->
	<!-- Javascript -->
	<script src="https://code.jquery.com/jquery-3.6.3.min.js"
		integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
	<script src="assets/plugins/popper.min.js"></script>
	<script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>
	<!-- Page Specific JS -->
	<script src="assets/plugins/smoothscroll.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
	<script src="assets/js/highlight-custom.js"></script>
	<script src="assets/plugins/simplelightbox/simple-lightbox.min.js"></script>
	<script src="assets/js/docs.js"></script>
	<script src="assets/js/app.js"></script>
</body>

</html>